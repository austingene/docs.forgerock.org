<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Chapter&nbsp;11.&nbsp;Configuring Synchronization</title><link rel="stylesheet" type="text/css" href="coredoc.css"><link rel="stylesheet" type="text/css" href="css/coredoc.css"><link rel="stylesheet" type="text/css" href="sh/shCore.css"><link rel="stylesheet" type="text/css" href="sh/shCoreEclipse.css"><link rel="stylesheet" type="text/css" href="sh/shThemeEclipse.css"><script src="http://code.jquery.com/jquery-1.11.0.min.js" type="text/javascript"></script><script src="uses-jquery.js" type="text/javascript"></script><script src="sh/shCore.js" type="text/javascript"></script><script src="sh/shBrushAci.js" type="text/javascript"></script><script src="sh/shBrushBash.js" type="text/javascript"></script><script src="sh/shBrushCsv.js" type="text/javascript"></script><script src="sh/shBrushHttp.js" type="text/javascript"></script><script src="sh/shBrushJava.js" type="text/javascript"></script><script src="sh/shBrushJScript.js" type="text/javascript"></script><script src="sh/shBrushLDIF.js" type="text/javascript"></script><script src="sh/shBrushPlain.js" type="text/javascript"></script><script src="sh/shBrushProperties.js" type="text/javascript"></script><script src="sh/shBrushXml.js" type="text/javascript"></script><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="OpenIDM Integrator's Guide"><link rel="up" href="index.html" title="OpenIDM Integrator's Guide"><link rel="prev" href="chap-resource-conf.html" title="Chapter&nbsp;10.&nbsp;Connecting to External Resources"><link rel="next" href="chap-scheduler-conf.html" title="Chapter&nbsp;12.&nbsp;Scheduling Tasks and Events"><link rel="copyright" href="legalnotice.html" title="Legal Notice"><script type="text/javascript">SyntaxHighlighter.all();</script>
<link rel="shortcut icon" href="http://forgerock.org/favicon.ico">
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;11.&nbsp;Configuring Synchronization</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="chap-resource-conf.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="chap-scheduler-conf.html">Next</a></td></tr></table><hr></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="chap-synchronization"></a>Chapter&nbsp;11.&nbsp;Configuring Synchronization</h1></div></div></div><div class="toc"><div class="toc-title">Table of Contents</div><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#sync-types">11.1. Types of Synchronization</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#sync-flexible-data">11.2. Flexible Data Model</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#basic-flow">11.3. Basic Data Flow Configuration</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#recon-over-rest">11.4. Managing Reconciliation Over REST</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#recon-by-query">11.5. Restricting Reconciliation by Using Queries</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#recon-by-id">11.6. Restricting Reconciliation to a Specific ID</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#querying-recon-logs">11.7. Querying the Reconciliation Audit Log</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#livesync-retry-strategy">11.8. Configuring the LiveSync Retry Policy</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#handling-sync">11.9. Synchronization Situations and Actions</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#asynchronous-reconciliation">11.10. Asynchronous Reconciliation</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#case-sensitivity">11.11. Configuring Case Sensitivity for Data Stores</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#reconciliation-optimization">11.12. Reconciliation Optimization</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#correlation">11.13. Correlation Queries</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#advanced-dataflow">11.14. Advanced Data Flow Configuration</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#scheduling-synchronization">11.15. Scheduling Synchronization</a></span></dt></dl></div><a class="indexterm" name="d0e7733"></a><p>
  One of the core services of OpenIDM is synchronizing identity data from
  different resources. This chapter explains what you must know to get started
  configuring OpenIDM's flexible synchronization mechanism, and illustrates the
  concepts with examples.
 </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sync-types"></a>11.1.&nbsp;Types of Synchronization</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#sync-types-automatic">11.1.1. How Automatic Sync works with <code class="literal">onSync</code></a></span></dt></dl></div><a class="indexterm" name="d0e7741"></a><p>
   Synchronization happens either when OpenIDM receives a change directly, or
   when OpenIDM discovers a change on an external resource.
  </p><p>
   For direct changes to OpenIDM, OpenIDM immediately pushes updates to all
   external resources configured to receive the updates. A direct change can
   originate not only as a write request through the REST interface, but also as
   an update resulting from reconciliation with another resource.
  </p><div class="variablelist"><p>
    OpenIDM discovers and synchronizes changes from external resources
    through reconciliation and LiveSync.
   </p><p>
    In contrast, OpenIDM synchronizes changes from internal resources to
    external targets using automatic sync.
   </p><dl class="variablelist"><dt><span class="term">Reconciliation</span></dt><dd><a class="indexterm" name="d0e7759"></a><p>
      In identity management, <em class="firstterm">reconciliation</em> is the
      process of bidirectional synchronization of objects between different data
      stores. Reconciliation applies mainly to user objects, although OpenIDM
      can reconcile any objects, including groups and roles.
     </p><p>
      To perform reconciliation, OpenIDM analyzes both source and target systems
      to uncover the differences that it must reconcile. Reconciliation can
      therefore be a heavyweight process. When working with large data sets,
      finding all changes can be more work than processing the changes.
     </p><p>
      Reconciliation is, however, thorough. It recognizes system error
      conditions and catches changes that might be missed by the more
      lightweight LiveSync mechanism. Reconciliation therefore serves as the
      basis for compliance and reporting functionality.
     </p></dd><dt><span class="term">LiveSync</span></dt><dd><a class="indexterm" name="d0e7775"></a><p>
      <em class="firstterm">LiveSync</em> captures the changes that occur on a
      remote system, then pushes those changes to OpenIDM. OpenIDM uses the
      defined mappings to replay the changes where they are required - either in
      the OpenIDM repository, or on another remote system, or both. Unlike
      reconciliation, LiveSync uses a polling system, and is intended to react
      quickly to changes as they happen.
     </p><p>
      To perform this polling, LiveSync relies on a change detection mechanism
      on the external resource to determine which objects have changed. The
      change detection mechanism is specific to the external resource, and can
      be a time stamp, a sequence number, a change vector or other any method of
      recording changes that have occurred on the system. For example, OpenDJ
      implements a change log that provides OpenIDM with a list of objects that
      have changed since the last request. Active Directory implements a change
      sequence number, and certain databases might have a
      <code class="literal">lastChange</code> attribute.
     </p></dd><dt><span class="term">Automatic sync</span></dt><dd><p>
      <em class="firstterm">Automatic sync</em> automatically pushes changes made in
      the OpenIDM internal repository to external systems.
     </p><p>
      In other words, automatic sync pushes data in the opposite direction to
      LiveSync. The section that follows describes additional features that
      can be included with automatic sync.
     </p></dd></dl></div><p>
   To determine what to synchronize, and how to carry out synchronization,
   OpenIDM relies on mappings configured in the
   <code class="literal">/path/to/conf/sync.json</code> file. LiveSync and automatic sync
   rely on the mappings configured once per OpenIDM server.
  </p><p>
   For reconciliation or LiveSync, you can schedule changes as described in
   <a href="../../integrators-guide/index/chap-scheduler-conf.html" class="link"><em class="citetitle">Scheduling
    Tasks and Events</em></a>.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sync-types-automatic"></a>11.1.1.&nbsp;How Automatic Sync works with <code class="literal">onSync</code></h3></div></div></div><p>
     When automatic sync is used to push a large number of changes to external
     databases, that process takes time. Problems such as lost connections
     could happen, resulting in partial synchronization.
    </p><p>
     For example, if a Human Resources manager adds a group of new employees in
     one database, a partial synchronization may mean that some of those
     employees do not have access to their email or other systems.
    </p><p>
     Automatic sync assumes that the external data sources include all data
     currently in the internal OpenIDM repository. If that does not reflect
     your configuration, you should start either with an initial reconciliation,
     or with LiveSync as described in the Installation Guide,
     <a href="../../install-guide/index/chap-samples.html#more-sample6" class="link"><em class="citetitle">Sample 6 - LiveSync
     with an AD Server</em></a>.
    </p><p>
     An example of automatic sync is depicted in the OpenIDM Installation Guide,
     <a href="../../install-guide/index/chap-samples.html#more-sample5b" class="link"><em class="citetitle">Sample 5b - Compensated
     Synchronization with <code class="literal">onSync</code></em></a>. That
     sample demonstrates how OpenIDM compensates for the failure of an external
     resource.
    </p><p>
     OpenIDM includes an optional <code class="literal">onSync</code> hook, which you
     can include in the <code class="filename">/path/to/conf/managed.json</code> file.
     A sample excerpt is shown here:
    </p><pre class="brush: javascript;">
...
"onDelete" : {
    "type" : "text/javascript",
    "file" : "ui/onDelete-user-cleanup.js"
    },
"onSync" : {
    "type" : "text/javascript",
    "file" : "compensate.js"
    },
"properties" : [
    ...
    </pre><p>
     Note the reference from <code class="literal">onSync</code> to
     <code class="filename">compensate.js</code>. You can find that file in the
     <code class="filename">/path/to/openidm/bin/defaults/script</code> directory.
    </p><p>
     When a change to a user is made, either in the UI or through a REST call,
     a change is made to the managed object for that user.
    </p><p>
     The automatic sync feature of OpenIDM attempts to synchronize the change
     (and any other pending changes) to the external data store(s). The
     automatic sync process is configured in the associated
     <code class="filename">sync.json</code> configuration file.
    </p><p>
     Look at the contents of the <code class="filename">sync.json</code> file. It might
     start with source and target mappings similar to:
    </p><pre class="brush: javascript;">
   ...
   "mappings" : [
     {
       "name" : "managedUser_systemAdAccounts",
       "source" : "managed/user",
       "target" : "system/ad/account",
     ...
    </pre><p>
     Based on this excerpt, automatic synchronization takes information from the
     internal OpenIDM managed user data store, and synchronizes that information
     to the AD data store. Once complete, it proceeds down the file to the
     next <code class="literal">source</code> and <code class="literal">target</code> to be
     synchronized.
    </p><p>
     The <code class="filename">compensate.js</code> script is designed to avoid
     partial synchronization. If synchronization proceeds to completion, OpenIDM
     exits from the script, based on some of the first active entries in the file:
    </p><pre class="brush: javascript;">
if (syncResults.success) {
     logger.debug("sync was a success; no compensation necessary");
     return;
}</pre><p>
     If synchronization does not complete, OpenIDM proceeds through the
     remainder of the <code class="filename">compensate.js</code> script, with warning
     messages related to the sync action (<code class="literal">notifyCreate, notifyUpdate,
     notifyDelete</code>, along with the error that caused the sync failure,
     which should be available in the standard OpenIDM log file.
    </p><p>
     Without the <code class="filename">compensate.js</code> script, any issues with
     connections to an external resource can lead to data stores that are
     out of sync, such as the example cited earlier where some new employees
     do not have access to their corporate email accounts.
    </p><p>
     With the <code class="filename">compensate.js</code> script, any such errors will
     result in each data store using the information it had before
     automatic synchronization started. OpenIDM stores that information,
     temporarily, in properties such as <code class="literal">oldObject</code> and
     <code class="literal">oldTarget</code>.
    </p><p>
     In this particular example, human resource managers should see that
     new employees are not shown in their database. Then, the administrators
     of the OpenIDM system can check log files for errors, address them, and
     then restart automatic synchronization with a new REST call.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sync-flexible-data"></a>11.2.&nbsp;Flexible Data Model</h2></div></div></div><a class="indexterm" name="d0e7912"></a><p>
   Identity management software tends to favor either a meta-directory data
   model, where all data are mirrored in a central repository, or a virtual data
   model, where only a minimum set of attributes are stored centrally, and most
   are loaded on demand from the external resources in which they are stored.
   The meta-directory model offers fast access at the risk of getting outdated
   data. The virtual model guarantees fresh data, but pays for that guarantee in
   terms of performance.
  </p><p>
   OpenIDM leaves the data model choice up to you. You determine the right trade
   offs for a particular deployment. OpenIDM does not hard code any particular
   schema or set of attributes stored in the repository. Instead, you define how
   external system objects map onto managed objects, and OpenIDM dynamically
   updates the repository to store the managed object attributes that you
   configure.
  </p><p>
   You can, for example, choose to follow the data model defined in the Simple
   Cloud Identity Management (<a class="link" href="http://www.simplecloud.info/specs/draft-scim-core-schema-00.html" target="_blank">SCIM</a>) specification. The following object represents a SCIM user.
  </p><pre class="brush: javascript;">
{
    "userName": "james1",
    "familyName": "Berg",
    "givenName": "James",
    "email": [
        "james1@example.com"
    ],
    "description": "Created by OpenIDM REST.",
    "password": "asdfkj23",
    "displayName": "James Berg",
    "phoneNumber": "12345",
    "employeeNumber": "12345",
    "userType": "Contractor",
    "title": "Vice President",
    "active": true
}</pre><div class="note"><h3 class="title">Note</h3><p>
    Avoid using the dash character ( <code class="literal">-</code> ) in property names,
    like <code class="literal">last-name</code>, as dashes in names make JavaScript syntax
    more complex. If you cannot avoid the dash, then write
    <code class="literal">source['last-name']</code> instead of
    <code class="literal">source.last-name</code> in your JavaScript.
   </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basic-flow"></a>11.3.&nbsp;Basic Data Flow Configuration</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#connector-config-files">11.3.1. Connector Configuration Files</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#synchronization-mappings-file">11.3.2. Synchronization Mappings File</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#sync-encrypted-values">11.3.3. Using Encrypted Values</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#restricting-http-access">11.3.4. Restricting HTTP Access to Sensitive Data</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#constructing-attributes">11.3.5. Constructing and Manipulating Attributes</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#reusing-links">11.3.6. Reusing Links</a></span></dt></dl></div><p>Data flow for synchronization involves the following elements:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Connector configuration files
  (<code class="filename">conf/provisioner-*.json</code>), with one file per external
  resource.</p></li><li class="listitem"><p>Synchronization mappings file
  (<code class="filename">conf/sync.json</code>), with one file per OpenIDM instance.
  </p></li><li class="listitem"><p>A links table that OpenIDM maintains in its repository.</p></li><li class="listitem"><p>The scripts required to check objects and manipulate attributes.</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="connector-config-files"></a>11.3.1.&nbsp;Connector Configuration Files</h3></div></div></div><a class="indexterm" name="d0e7970"></a><p>Connector configuration files map external resource objects to OpenIDM
     objects, and are described in detail in the chapter on <a href="../../integrators-guide/index/chap-resource-conf.html" class="link"><em class="citetitle">Connecting to
     External Resources</em></a>. Connector configuration files are
     named <code class="filename">openidm/conf/provisioner.<em class="replaceable"><code>resource-name</code></em>.json</code>,
     where <em class="replaceable"><code>resource-name</code></em> reflects the connector
     technology and external resource, such as
     <code class="literal">openicf-xml</code>.</p><p>An excerpt from an example connector configuration follows. The
     example shows the name for the connector and two attributes of an account
     object type. In the attribute mapping definitions, the attribute name is
     mapped from the <code class="literal">nativeName</code>, the attribute name used on
     the external resource, to the attribute name used in OpenIDM. Thus the
     example shows that the <code class="literal">sn</code> attribute in LDAP is mapped to
     <code class="literal">lastName</code> in OpenIDM. The <code class="literal">homePhone</code>
     attribute can have multiple values.</p><pre class="brush: javascript;">
{
    "name": "MyLDAP",
    "objectTypes": {
        "account": {
            "lastName": {
                "type": "string",
                "required": true,
                "nativeName": "sn",
                "nativeType": "string"
            },
            "homePhone": {
                "type": "array",
                "items": {
                    "type": "string",
                    "nativeType": "string"
                },
                "nativeName": "homePhone",
                "nativeType": "string"
            }
        }
    }
}</pre><p>In order for OpenIDM to access external resource objects and
    attributes, the object and its attributes must match the connector
    configuration. Note that the connector file only maps external resource
    objects to OpenIDM objects. To construct attributes and to manipulate
    their values, you use the synchronization mappings file.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="synchronization-mappings-file"></a>11.3.2.&nbsp;Synchronization Mappings File</h3></div></div></div><a class="indexterm" name="d0e8014"></a><a class="indexterm" name="d0e8019"></a><p>
     The synchronization mappings file (<code class="filename">openidm/conf/sync.json</code>)
     represents the core configuration for OpenIDM synchronization.
     </p><p>The <code class="filename">sync.json</code> file describes a set of mappings.
     Each mapping specifies how attributes from source objects correspond to
     attributes on target objects. The source and target indicate the direction
     for the data flow, so you must define a separate mapping for each data
     flow. For example, if you want data flows from an LDAP server to the
     repository and also from the repository to the LDAP server, you must
     define two separate mappings.</p><p>You identify external resource sources and targets as
     <code class="literal">system/<em class="replaceable"><code>name</code></em>/<em class="replaceable"><code>object-type</code></em></code>, where
     <em class="replaceable"><code>name</code></em> is the name used in the connector
     configuration file, and <em class="replaceable"><code>object-type</code></em> is the
     object defined in the connector configuration file list of object types.
     For objects in OpenIDM's internal repository, you use
     <code class="literal">managed/<em class="replaceable"><code>object-type</code></em></code>, where
     <em class="replaceable"><code>object-type</code></em> is defined in
     <code class="filename">openidm/conf/managed.json</code>. The name for the mapping
     by convention is set to a string of the form
     <code class="literal"><em class="replaceable"><code>source</code></em>_<em class="replaceable"><code>target</code></em></code>, as shown in the following example.</p><pre class="brush: javascript;">
{
    "mappings": [
        {
            "name": "systemLdapAccounts_managedUser",
            "source": "system/MyLDAP/account",
            "target": "managed/user",
            "properties": [
                {
                    "target": "sn",
                    "source": "lastName"
                },
                {
                    "target": "telephoneNumber",
                    "source": "homePhone"
                },
                {
                    "target": "phoneExtension",
                    "default": "0047"
                },
                {
                    "target": "mail",
                    "comment": "Set mail if non-empty.",
                    "source": "email",
                    "condition": {
                        "type": "text/javascript",
                        "source": "(object.email != null)"
                    }
                },
                {
                    "target": "displayName",
                    "source": "",
                    "transform": {
                        "type": "text/javascript",
                        "source": "source.lastName +', ' + source.firstName;"
                    }
                }
            ]
        }
    ]
}</pre><p>In this example, the source is the external resource,
     <code class="literal">MyLDAP</code>, and the target is OpenIDM's repository,
     specifically the managed user objects. The <code class="literal">properties</code>
     reflect OpenIDM attribute names. For example, the mapping has the
     attribute <code class="literal">lastName</code> defined in the
     <code class="literal">MyLDAP</code> connector configuration file mapped to
     <code class="literal">sn</code> in the OpenIDM managed user object. Notice
     that the attribute names come from the connector configuration, rather
     than the external resource itself.</p><a class="indexterm" name="d0e8085"></a><p>You can create attributes on the target as part of the mapping. In
     the preceding example, a <code class="literal">phoneExtension</code> attribute with
     a default value of <code class="literal">0047</code> is created on the target. The
     <code class="literal">"default"</code> property can also be used to specify the
     value to assign to the target property if the <code class="literal">"source"</code>
     property and the <code class="literal">"transform"</code> script yield a null value.
     If no value is specified, the default value is null.
     </p><a class="indexterm" name="d0e8107"></a><p>You can also set up conditions under which OpenIDM maps attributes
     as shown for the email attribute in the example. By default, OpenIDM
     synchronizes all attributes. In the example, the mail attribute is set
     only if the script for the condition returns <code class="literal">true</code>.
     </p><a class="indexterm" name="d0e8117"></a><p>OpenIDM also enables you to transform attributes. In the example,
     the value of the <code class="literal">displayName</code> attribute is set using a
     combination of the <code class="literal">lastName</code> and
     <code class="literal">firstName</code> attribute values from the source. For
     transformations, the <code class="literal">source</code> property is optional.
     However, the source object is only available when you specify the
     <code class="literal">source</code> property. Therefore, in order to use
     <code class="literal">source.lastName</code> and <code class="literal">source.firstName</code>
     to calculate the <code class="literal">displayName</code>, the example specifies
     <code class="literal">"source" : ""</code>.</p><p>To add a flow from the repository to <code class="literal">MyLDAP</code>,
     you would define a mapping with source <code class="literal">managed/user</code>
     and target <code class="literal">system/MyLDAP/account</code>, named for example
     <code class="literal">managedUser_systemLdapAccounts</code>.</p><p>The following image shows the paths to objects in the OpenIDM
     namespace.</p><div class="mediaobject" align="center"><a name="figure-service-tree"></a><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tr><td align="center"><img src="images/ServiceTree.png" align="middle" height="360" alt="OpenIDM namespace and object paths"></td></tr></table><div class="longdesc-link" align="right"><br clear="all"><span class="longdesc-link">[<a href="figure-service-tree.html" target="longdesc">D</a>]</span></div><div class="caption"><p>OpenIDM stores managed objects in the repository, and exposes
       them under <code class="literal">/openidm/managed</code>. System objects on
       external resources are exposed under
       <code class="literal">/openidm/system</code>.</p></div></div><div class="variablelist"><a class="indexterm" name="d0e8186"></a><p>
       By default, OpenIDM synchronizes all objects that match those defined in
       the connector configuration for the resource. Many connectors allow you
       to limit the scope of objects that the connector accesses. For example,
       the LDAP connector allows you to specify base DNs and LDAP filters so
       that you do not need to access every entry in the directory. OpenIDM also
       allows you to filter what is considered a valid source or valid target
       for synchronization by using scripts. To apply these filters, use the
       <code class="literal">validSource</code>, and <code class="literal">validTarget</code>
       properties in your mapping.
      </p><dl class="variablelist"><dt><span class="term">validSource</span></dt><dd><p>A script that determines if a source object is valid to be
         mapped. The script yields a boolean value: <code class="literal">true</code>
         indicates that the source object is valid; <code class="literal">false</code>
         can be used to defer mapping until some condition is met. In the root
         scope, the source object is provided in the <code class="literal">"source"</code>
         property. If the script is not specified, then all source objects are
         considered valid.</p><pre class="brush: javascript;">
{
    "validSource": {
        "type": "text/javascript",
        "source": "source.ldapPassword != null"
    }
}
</pre></dd><dt><span class="term">validTarget</span></dt><dd><p>A script, used during reconciliation's second phase, that
        determines if a target object is valid to be mapped. The script yields
        a boolean value: <code class="literal">true</code> indicates that the target
        object is valid; <code class="literal">false</code> indicates that the target
        object should not be included in reconciliation. In the root scope, the
        source object is provided in the <code class="literal">"target"</code> property.
        If the script is not specified, then all target objects are considered
        valid for mapping.</p><pre class="brush: javascript;">
{
    "validTarget": {
        "type": "text/javascript",
        "source": "target.employeeType == 'internal'"
    }
}
</pre></dd></dl></div><p>During synchronization, your scripts always have access to a
     <code class="literal">source</code> object and a <code class="literal">target</code> object.
     Examples already shown in this section use <code class="literal">source.<em class="replaceable"><code>attributeName</code></em></code> to retrieve attributes from the
     source objects. Your scripts can also write to target attributes using
     <code class="literal">target.<em class="replaceable"><code>attributeName</code></em></code>
     syntax.</p><pre class="brush: javascript;">
{
    "onUpdate": {
        "type": "text/javascript",
        "source": "if (source.email != null) {target.mail = source.email;}"
    }
}</pre><p>See the <a href="../../integrators-guide/index/appendix-scripting.html" class="link"><em class="citetitle">Scripting
     Reference</em></a> appendix for more on scripting.</p><p>By default, all mappings participate in automatic synchronization
   operations. You can prevent a specific mapping from participating in
   automatic synchronization by setting the <code class="literal">"enableSync"</code>
   property of that mapping to false. In the following example, automatic
   synchronization is disabled. This means that changes to objects in the internal
   repository are not automatically propagated to the LDAP directory. To
   propagate changes to the LDAP directory, reconciliation must be launched
   manually.</p><pre class="brush: javascript;">
{
    "mappings" : [
        {
            "name" : "managedUser_systemLdapAccounts",
            "source" : "managed/user",
            "target" : "system/ldap/account",
            "enableSync" : false,
             ....
}
   </pre><p>
    Note that if <code class="literal">enableSync</code> is set to <code class="literal">false</code>
    for a system to managed user mapping (for example
    <code class="literal">"systemLdapAccounts_managedUser"</code>), LiveSync is disabled
    for that mapping.
   </p><p>
    If a source resource is empty, the default behavior is for a reconciliation
    operation to exit, without failure, and to log a warning, similar to the
    following:
   </p><div class="screen"><pre>
2014-03-20 10:41:18:918 WARN Cannot perform reconciliation with an empty source
    object set, unless explicitly configured to allow it.
   </pre></div><p>
    The reconciliation summary is also logged in the reconciliation audit log.
   </p><p>
    This behavior prevents reconciliation operations from accidentally deleting
    everything in a target resource. For example, in the event that a source
    system is unavailable but erroneously reporting its status as "up", the
    absence of source objects should not result in objects being removed on the
    target resource.
   </p><p>
    There might be situations in which you do want reconciliations of an empty
    source resource to proceed. In this case, you can override the default
    behavior by setting the <code class="literal">"allowEmptySourceSet"</code> property to
    <code class="literal">true</code> in the mapping. For example:
   </p><pre class="brush: plain;">
{
    "mappings" : [
        {
        "name" : "systemXmlfileAccounts_managedUser",
        "source" : "system/xmlfile/account",
        "allowEmptySourceSet" : true,
        ...
   </pre><p>
    Reconciliation of an empty source effectively wipes out the target.
   </p><p>
    You can update mappings in the synchronization configuration file
    (<code class="filename">sync.json</code>) while the server is running, provided you
    do not update a mapping that is currently in use by a reconciliation
    process.
   </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sync-encrypted-values"></a>11.3.3.&nbsp;Using Encrypted Values</h3></div></div></div><a class="indexterm" name="d0e8305"></a><p>OpenIDM supports reversible encryption of attribute values for
   managed objects. Attribute values to encrypt include passwords,
   authentication questions, credit card numbers, and social security numbers.
   If passwords are already encrypted on the external resource, they are
   generally excluded from the synchronization process. For more information,
   see <a href="../../integrators-guide/index/chap-passwords.html" class="link">
           <em class="citetitle">Managing Passwords</em></a>.</p><p>You configure encryption in the managed object configuration (in the
   <code class="filename">openidm/conf/managed.json</code> file). The following extract
   of that file shows a managed object configuration that encrypts and decrypts
   <code class="literal">securityAnswer</code>, <code class="literal">ssn</code>, and
   <code class="literal">password</code> attributes using the default symmetric
   key, and additional scripts for extra passwords.</p><pre class="brush: javascript;">
{
    "objects": [
        {
            "name": "user",
            ...
            "properties": [
                {
                    "name": "securityAnswer",
                    "encryption": {
                        "key": "openidm-sym-default"
                    }
                },
                {
                    "name": "ssn",
                    "encryption": {
                        "key": "openidm-sym-default"
                    }
                },
                {
                    "name": "password",
                    "encryption": {
                        "key": "openidm-sym-default"
                    }
                }
            ],
            ...
          }
    ]
}</pre><p>Do not use the default symmetric key,
   <code class="literal">openidm-sym-default</code>, in production. See the chapter on
   <a href="../../integrators-guide/index/chap-security.html" class="link"><em class="citetitle">Securing
   and Hardening OpenIDM</em></a> for instructions on adding your
   own symmetric key.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="restricting-http-access"></a>11.3.4.&nbsp;Restricting HTTP Access to Sensitive Data</h3></div></div></div><p>You can protect specific sensitive data stored in the repository by
   marking the corresponding properties as "private". Private data, whether it
   is encrypted or not, is not accessible over the REST interface. Properties
   that are marked as private are removed from an object when that object is
   retrieved over REST.</p><p>To mark a property as private, set its <code class="literal">"scope"</code> to
   <code class="literal">"private"</code> in the <code class="filename">conf/managed.json</code>
   file.</p><p>The following extract of the <code class="filename">managed.json</code> file
   shows how HTTP access is prevented on the <code class="literal">password</code> and
   <code class="literal">securityAnswer</code> properties.</p><pre class="brush: javascript;">
       "properties" : [
           {
               "name" : "securityAnswer",
               "encryption" : {
                   "key" : "openidm-sym-default"
               },
               "scope" : "private"
           },
           {
               "name" : "password",
               "encryption" : {
                   "key" : "openidm-sym-default"
               },
               "scope" : "private"
   </pre><p>A potential caveat with using private properties is that such
   properties are <span class="emphasis"><em>removed</em></span> if an object is updated by
   using an HTTP <code class="literal">PUT</code> request. A <code class="literal">PUT</code>
   request replaces the entire object in the repository. Because properties
   that are marked as private are ignored in HTTP requests, these properties
   are effectively removed from the object when the update is done. To work
   around this limitation, do not use <code class="literal">PUT</code> requests if you
   have configured private properties. Instead, use a <code class="literal">PATCH</code>
   request to update only those properties that need to be changed.
   </p><p>For example, to update the <code class="literal">givenName</code> of user jdoe,
    you could run the following command:</p><div class="screen"><pre>
$ <strong>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 --data '[
    {
    "operation":"replace",
    "field":"/givenName",
    "value":"Jon"
    }
 ]' \
 "https://localhost:8443/openidm/managed/user?_action=patch&amp;_queryId=for-userName&amp;uid=jdoe"</strong>
   </pre></div><div class="note"><h3 class="title">Note</h3><p>The filtering of private data applies only to direct HTTP read
    and query calls on managed objects. No automatic filtering is done for
    internal callers, and the data that these callers choose to expose.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="constructing-attributes"></a>11.3.5.&nbsp;Constructing and Manipulating Attributes</h3></div></div></div><a class="indexterm" name="d0e8404"></a><p>
    OpenIDM enables you to construct and manipulate attributes using scripts
    that are triggered when an object is created (onCreate), updated (onUpdate),
    retrieved (onRetrieve), or deleted (onDelete). Additional scripts are
    available when a managed object requires validation (onValidate), and when
    an object is about to be stored in the repository (onStore). Similar scripts
    are available for when a link is created (onLink) or removed (onUnlink).
   </p><p>The following example derives a DN for an LDAP entry when the entry
   is created in the internal repository.</p><pre class="brush: javascript;">
{
    "onCreate": {
        "type": "text/javascript",
        "source":
            "target.dn = 'uid=' + source.uid + ',ou=people,dc=example,dc=com'"
    }
}</pre><p>
    In addition, OpenIDM supports the use of post-action scripts, including
    after the creation of an object is complete (postCreate), after the update
    of an object is complete (postUpdate), and after the deletion of an object
    (postDelete).
   </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reusing-links"></a>11.3.6.&nbsp;Reusing Links</h3></div></div></div><a class="indexterm" name="d0e8420"></a><p>When two mappings exist to synchronize the same objects bidirectionally,
   you can use the <code class="literal">links</code> property in one mapping to have
   OpenIDM use the same internally managed link for both mappings. Otherwise,
   if no <code class="literal">links</code> property is specified, OpenIDM maintains a
   link for each mapping.</p><p>The following excerpt shows two mappings, one from MyLDAP accounts
   to managed users, and another from managed users to MyLDAP accounts. In
   the second mapping, the <code class="literal">link</code> property tells OpenIDM
   to reuse the links created in the first mapping, rather than create new
   links.</p><pre class="brush: javascript;">
{
    "mappings": [
        {
            "name": "systemMyLDAPAccounts_managedUser",
            "source": "system/MyLDAP/account",
            "target": "managed/user"
        },
        {
            "name": "managedUser_systemMyLDAPAccounts",
            "source": "managed/user",
            "target": "system/MyLDAP/account",
            "links": "systemMyLDAPAccounts_managedUser"
        }
    ]
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recon-over-rest"></a>11.4.&nbsp;Managing Reconciliation Over REST</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#triggering-recons">11.4.1. Triggering a Reconciliation Run</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#recon-details">11.4.2. Obtaining the Details of a Reconciliation Run</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#canceling-recons">11.4.3. Canceling a Reconciliation Run</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#listing-recons">11.4.4. Listing Reconciliation Runs</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#livesync-over-rest">11.4.5. Triggering LiveSync Over REST</a></span></dt></dl></div><p>
   You can trigger, cancel, and monitor reconciliation operations over REST,
   using the REST endpoint
   <code class="literal">https://localhost:8443/openidm/recon</code>.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="triggering-recons"></a>11.4.1.&nbsp;Triggering a Reconciliation Run</h3></div></div></div><p>
    The following example triggers a reconciliation operation based on the
    <code class="literal">systemLdapAccounts_managedUser</code> mapping. The mapping is
    defined in the file <code class="filename">conf/sync.json</code>.
   </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon?_action=recon&amp;mapping=systemLdapAccounts_managedUser"</pre></div><p>
    By default, an assigned reconciliation run ID is returned immediately when
    the reconciliation operation is initiated. Clients can make subsequent calls
    to the reconciliation service, using this reconciliation run ID to query its
    state and to call operations on it.
   </p><p>
    For example, the reconciliation run initiated previously would return
    something similar to the following:
   </p><div class="screen"><pre>{"_id":"0890ad62-4738-4a3f-8b8e-f3c83bbf212e"}</pre></div><p>
    To have the entire reconciliation run complete before the reconciliation
    run ID is returned, set the <code class="literal">waitForCompletion</code> property to
    <code class="literal">true</code> when the reconciliation is initiated. For example:
   </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon?_action=recon&amp;mapping=systemLdapAccounts_managedUser&amp;waitForCompletion=true"
   </pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="recon-details"></a>11.4.2.&nbsp;Obtaining the Details of a Reconciliation Run</h3></div></div></div><p>
     You can display the details of a particular reconciliation run over REST by
     specifying the reconciliation run ID in the URL. For example, the following
     call shows the details of the reconciliation run initiated in the previous
     section:
    </p><div class="screen"><pre>$ <strong>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/recon/0890ad62-4738-4a3f-8b8e-f3c83bbf212e"</strong>
     <em>{
  "ended": "2014-03-06T07:00:32.094Z",
  "_id": "7a07c100-4f11-4d7e-bf8e-fa4594f99d58",
  "mapping": "systemLdapAccounts_managedUser",
  "state": "SUCCESS",
  "stage": "COMPLETED_SUCCESS",
  "stageDescription": "reconciliation completed.",
  "progress": {
     "links": {
       "created": 0,
       "existing": {
         "total": "1",
         "processed": 1
       }
     },
     "target": {
       "created": 0,
       "existing": {
         "total": "3",
         "processed": 3
       }
     },
     "source": {
       "existing": {
         "total": "1",
         "processed": 1
       }
     }
  },
  "situationSummary": {
     "UNASSIGNED": 2,
     "TARGET_IGNORED": 0,
     "SOURCE_IGNORED": 0,
     "MISSING": 0,
     "FOUND": 0,
     "AMBIGUOUS": 0,
     "UNQUALIFIED": 0,
     "CONFIRMED": 1,
     "SOURCE_MISSING": 0,
     "ABSENT": 0
  },
  "started": "2014-03-06T07:00:31.907Z"</em>
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="canceling-recons"></a>11.4.3.&nbsp;Canceling a Reconciliation Run</h3></div></div></div><p>
     You can cancel a reconciliation run by sending a REST call with the
     <code class="literal">cancel</code> action, specifying the reconciliation run ID. For
     example, the following call cancels the reconciliation run initiated in the
     previous section:
    </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon/0890ad62-4738-4a3f-8b8e-f3c83bbf212e?_action=cancel"</pre></div><p>
     The output for a reconciliation cancellation request is similar to the
     following:
    </p><div class="screen"><pre>{
     "status":"SUCCESS",
     "action":"cancel",
     "_id":"0890ad62-4738-4a3f-8b8e-f3c83bbf212e"
}</pre></div><p>
     If you specified that the call should wait for completion before the ID is
     returned, you can obtain the reconciliation run ID from the list of active
     reconciliations, as described in the following section.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="listing-recons"></a>11.4.4.&nbsp;Listing Reconciliation Runs</h3></div></div></div><p>
     You can display a list of reconciliation processes that have completed, and
     those that are in progress, by running a RESTful GET on
     <code class="literal">"https://localhost:8443/openidm/recon"</code>. The following
     example displays all reconciliation runs.
    </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/recon"
    </pre></div><p>
     The output of such a request is similar to the following, with one item for
     each reconciliation run.
    </p><div class="screen"><pre>{
   "reconciliations": [
     {
       "ended": "2014-03-06T06:14:11.845Z",
       "_id": "4286510e-986a-4521-bfa4-8cd1e039a7f5",
       "mapping": "systemLdapAccounts_managedUser",
       "state": "SUCCESS",
       "stage": "COMPLETED_SUCCESS",
       "stageDescription": "reconciliation completed.",
       "progress": {
         "links": {
           "created": 1,
           "existing": {
           "total": "0",
           "processed": 0
         }
       },
       "target": {
         "created": 1,
         "existing": {
           "total": "2",
           "processed": 2
         }
       },
       "source": {
         "existing": {
           "total": "1",
           "processed": 1
         }
       }
     },
     "situationSummary": {
       "UNASSIGNED": 2,
       "TARGET_IGNORED": 0,
       "SOURCE_IGNORED": 0,
       "MISSING": 0,
       "FOUND": 0,
       "AMBIGUOUS": 0,
       "UNQUALIFIED": 0,
       "CONFIRMED": 0,
       "SOURCE_MISSING": 0,
       "ABSENT": 1
     },
     "started": "2014-03-06T06:14:04.722Z"
   },
 ]
}</pre></div><div class="variablelist"><p>
      Each reconciliation run has the following properties:
     </p><dl class="variablelist"><dt><span class="term"><code class="literal">_id</code></span></dt><dd><p>
        The ID of the reconciliation run.
       </p></dd><dt><span class="term"><code class="literal">mapping</code></span></dt><dd><p>
        The name of the mapping, defined in the <code class="filename">conf/sync.json</code>
        file.
       </p></dd><dt><span class="term"><code class="literal">state</code></span></dt><dd><p>
        The high level state of the reconciliation run. Values can be as follows:
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ACTIVE</code>
         </p><p>
          The reconciliation run is in progress.
         </p></li><li class="listitem"><p>
          <code class="literal">CANCELED</code>
         </p><p>
          The reconciliation run was successfully canceled.
         </p></li><li class="listitem"><p>
          <code class="literal">FAILED</code>
         </p><p>
          The reconciliation run was terminated because of failure.
         </p></li><li class="listitem"><p>
          <code class="literal">SUCCESS</code>
         </p><p>
          The reconciliation run completed successfully.
         </p></li></ul></div></dd><dt><span class="term"><code class="literal">stage</code></span></dt><dd><p>
        The current stage of the reconciliation run's progress. Values can be as
        follows:
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ACTIVE_INITIALIZED</code>
         </p><p>
          The initial stage, when a reconciliation run is first created.
         </p></li><li class="listitem"><p>
          <code class="literal">ACTIVE_QUERY_ENTRIES</code>
         </p><p>
          Querying the source, target and possibly link sets to reconcile.
         </p></li><li class="listitem"><p>
          <code class="literal">ACTIVE_RECONCILING_SOURCE</code>
         </p><p>
          Reconciling the set of IDs retrieved from the mapping source.
         </p></li><li class="listitem"><p>
          <code class="literal">ACTIVE_RECONCILING_TARGET</code>
         </p><p>
          Reconciling any remaining entries from the set of IDs retrieved from
          the mapping target, that were not matched or processed during the
          source phase.
         </p></li><li class="listitem"><p>
          <code class="literal">ACTIVE_LINK_CLEANUP</code>
         </p><p>
          Checking whether any links are now unused and should be cleaned up.
         </p></li><li class="listitem"><p>
          <code class="literal">ACTIVE_PROCESSING_RESULTS</code>
         </p><p>
          Post-processing of reconciliation results.
         </p></li><li class="listitem"><p>
          <code class="literal">ACTIVE_CANCELING</code>
         </p><p>
          Attempting to abort a reconciliation run in progress.
         </p></li><li class="listitem"><p>
          <code class="literal">COMPLETED_SUCCESS</code>
         </p><p>
          Successfully completed processing the reconciliation run.
         </p></li><li class="listitem"><p>
          <code class="literal">COMPLETED_CANCELED</code>
         </p><p>
          Completed processing because the reconciliation run was aborted.
         </p></li><li class="listitem"><p>
          <code class="literal">COMPLETED_FAILED</code>
         </p><p>
          Completed processing because of a failure.
         </p></li></ul></div></dd><dt><span class="term"><code class="literal">stageDescription</code></span></dt><dd><p>
        A description of the stages described previously.
       </p></dd><dt><span class="term"><code class="literal">progress</code></span></dt><dd><p>
        The progress object has the following structure (annotated here with
        comments):
       </p><pre class="brush: javascript;">
"progress":{
  "source":{             // Progress on set of existing entries in the mapping source
    "existing":{
      "processed":1001,
        "total":"1001"   // Total number of entries in source set, if known, &#8220;?&#8221; otherwise
    }
  },
  "target":{             // Progress on set of existing entries in the mapping target
    "existing":{
      "processed":1001,
      "total":"1001"     // Total number of entries in target set, if known, &#8220;?&#8221; otherwise
    },
    "created":0          // New entries that were created
  },
  "links":{              // Progress on set of existing links between source and target
    "existing":{
      "processed":1001,
      "total":"1001"     // Total number of existing links, if known, &#8220;?&#8221; otherwise
    },
  "created":0            // Denotes new links that were created
  }
},
       </pre></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="livesync-over-rest"></a>11.4.5.&nbsp;Triggering LiveSync Over REST</h3></div></div></div><p>
    The ability to trigger LiveSync operations over REST, or by using the
    resource API, enables you to use an external scheduler to trigger a LiveSync
    operation, rather than using the OpenIDM scheduling mechanism.
   </p><div class="itemizedlist"><p>
     There are two ways in which to trigger a LiveSync operation over REST.
    </p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      Use the <code class="literal">_action=liveSync</code> parameter directly on the
      resource. This is the recommended method. The following example calls a
      LiveSync operation on the user accounts in an external LDAP system.
     </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/system/ldap/account?_action=liveSync"</pre></div></li><li class="listitem"><p>
      Target the <code class="literal">system</code> endpoint and supply a
      <code class="literal">source</code> parameter to identify the object that should be
      synchronized. This method matches the scheduler configuration and can
      therefore be used to test schedules before they are implemented.
     </p><p>
      The following example calls the same LiveSync operation as the previous
      example.
     </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/system?_action=liveSync&amp;source=system/ldap/account"</pre></div></li></ul></div><p>
    A successful LiveSync operation returns the following response:
   </p><div class="screen"><pre>{
    "_rev": "4",
    "_id": "SYSTEMLDAPACCOUNT",
    "connectorData": {
        "nativeType": "integer",
        "syncToken": 1
    }
}</pre></div><p>
    Do not run two identical LiveSync operations simultaneously - rather, ensure
    that the first operation has completed before a second similar operation is
    launched.
   </p><p>
    To troubleshoot a LiveSync operation that has not succeeded, you can include
    an optional parameter (<code class="literal">detailedFailure</code>) to return
    additional information. For example:
   </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/system/ldap/account?_action=liveSync&amp;detailedFailure=true"</pre></div><div class="note"><h3 class="title">Note</h3><p>
     The first time that a LiveSync operation is called, no synchronization
     token exists in the database to establish which changes have already been
     processed. The default LiveSync behavior is to locate the last existing
     entry in the change log, and to store that entry in the database as the
     current starting position from which changes should be applied. This
     behavior prevents LiveSync from processing changes that might already have
     been processed during an initial data load. Subsequent LiveSync operations
     will pick up and process any new changes.
    </p><p>
     Typically, in setting up LiveSync on a new system, you would load the data
     initially (by using reconciliation, for example) and then enable LiveSync,
     starting from that base point.
    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recon-by-query"></a>11.5.&nbsp;Restricting Reconciliation by Using Queries</h2></div></div></div><p>
   Every reconciliation operation performs a query on the source, and on the
   target resource, to determine which records should be reconciled. The default
   source and target queries are <code class="literal">query-all-ids</code>, which means
   that all records in both the source and the target are considered candidates
   for that reconciliation operation.
  </p><p>
   You can restrict reconciliation to specific entries by defining explicit
   source or target queries in the mapping configuration.
  </p><p>
   For example, to restrict reconciliation to only those records whose
   <code class="literal">employeeType</code> on the source resource is
   <code class="literal">Permanent</code>, you might specify a source query as follows:
  </p><pre class="brush: javascript;">
"mappings" : [
     {
         "name" : "managedUser_systemLdapAccounts",
         "source" : "managed/user",
         "target" : "system/ldap/account",
         "sourceQuery" : : {
                "queryFilter" : "employeeType eq \"Permanent\""
            },
...
  </pre><p>
   The format of the query can be any query type that is supported by the
   resource, and can include additional parameters, if applicable. OpenIDM
   3.0.0 supports the following query types.
  </p><div class="itemizedlist"><p>
    For queries on managed objects:
   </p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
     <code class="literal">_queryId</code> for arbitrary predefined, parameterized
     queries
    </p></li><li class="listitem"><p>
     <code class="literal">_queryExpression</code> for client-supplied queries, in native
     query format
    </p></li></ul></div><div class="itemizedlist"><p>
    For queries on system objects:
   </p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
     <code class="literal">_queryId=query-all-ids</code> (the only supported predefined
     query)
    </p></li><li class="listitem"><p>
     <code class="literal">_queryFilter</code> for arbitrary filters, in common filter
     notation
    </p></li></ul></div><p>
   The source and target queries send the query to the resource that is defined
   for that source or target, by default. You can override the resource to which
   the query is sent by specifying a <code class="literal">resourceName</code> in the
   query. For example, to query a specific endpoint instead of the source
   resource, you might modify the preceding source query as follows:
  </p><pre class="brush: javascript;">
"mappings" : [
    {
        "name" : "managedUser_systemLdapAccounts",
        "source" : "managed/user",
        "target" : "system/ldap/account",
        "sourceQuery" : {
            "resourceName" : "endpoint/scriptedQuery"
            "queryFilter" : "employeeType eq \"Permanent\""
        },
...
  </pre><p>
   To override a source or target query that is defined in the mapping, you can
   specify the query when you call the reconciliation operation. For example, if
   you wanted to reconcile all employee entries, and not just the permanent
   employees, you would run the reconciliation operation as follows:
  </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 --data '{"sourceQuery": {"_queryId" : "query-all-ids"}}' \
 "https://localhost:8443/openidm/recon?_action=recon&amp;mapping=managedUser_systemLdapAccounts"</pre></div><p>
   By default, a reconciliation operation runs both the source and target phase,
   that is both the source and the target resources are queried. To specify that
   either the source or target resource is not queried, set
   <code class="literal">runSourcePhase</code> or <code class="literal">runTargetPhase</code> to
   <code class="literal">false</code> in the mapping configuration
   (<code class="filename">conf/sync.json</code> file). For example, to prevent the
   target resource from being queried during the reconciliation operation
   configured in the previous example, you would amend the mapping configuration
   as follows:
  </p><pre class="brush: plain;">
{
    "mappings" : [
        {
            "name" : "systemLdapAccounts_managedUser",
            "source" : "system/ldap/account",
            "target" : "managed/user",
            "sourceQuery" : {
                "queryFilter" : "employeeType eq \"Permanent\""
            },
            "runTargetPhase" : false,
   ...
  </pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recon-by-id"></a>11.6.&nbsp;Restricting Reconciliation to a Specific ID</h2></div></div></div><p>
   In the same way that you can restrict reconciliation operations to specific
   records by using queries, you can specify an ID to restrict a reconciliation
   operation to a particular record.
  </p><p>
   To restrict reconciliation to a specific ID, use the
   <code class="literal">reconById</code> action, instead of the <code class="literal">recon</code>
   action when you call the reconciliation operation. Specify the ID with the
   <code class="literal">ids</code> parameter. Currently reconciling more than one ID with
   the <code class="literal">reconById</code> action is not supported.
  </p><p>
   The following example is based on the data from Sample 2b, which maps an
   LDAP server with the OpenIDM repository. The example reconciles only the user
   <code class="literal">bjensen</code>, using the
   <code class="literal">managedUser_systemLdapAccounts</code> mapping to update the user
   account in LDAP with the data from the OpenIDM repository. The
   <code class="literal">_id</code> for <code class="literal">bjensen</code> in this example is
   <code class="literal">b3c2f414-e7b3-46aa-8ce6-f4ab1e89288c</code>.
   The example assumes that automatic synchronization has been disabled and that
   a reconciliation operation is required to copy changes made in the repository
   to the LDAP system.
  </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/recon?_action=reconById&amp;mapping=managedUser_systemLdapAccounts&amp;ids=b3c2f414-e7b3-46aa-8ce6-f4ab1e89288c"</pre></div><p>
   A reconciliation by ID takes the default reconciliation options that are
   specified in the mapping, so the source and target queries, and source and
   target phases described in the previous section apply equally to
   reconciliation by ID.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querying-recon-logs"></a>11.7.&nbsp;Querying the Reconciliation Audit Log</h2></div></div></div><p>
     Reconciliation operations are logged in the file
     <code class="filename">/path/to/openidm/audit/recon.csv</code> and in the
     repository. You can read and query the reconciliation audit logs over the
     REST interface, as outlined in the following examples.
  </p><p>
     By default all <code class="literal">audit/recon</code> query responses are formatted
     based on the <code class="literal">entryType</code> of the entry. Fields that are not
     required for the specific entry type are stripped away from the response.
     For example, a <code class="literal">summary</code> entry would not need to include a
     null <code class="literal">targetObjectId</code> field, as this would not add
     information to a summary. You can specify that this auto-formatting be
     disabled and return the full entry for all entry types. To disable entry
     formatting, include <code class="literal">formatted=false</code> as a query parameter
     in the request.
    </p><p>
     To return all reconciliation operations logged in the audit log, run a
     RESTful GET on the <code class="literal">audit/recon</code> endpoint. For example:
    </p><div class="screen"><pre>
$ <strong>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/audit/recon"</strong></pre></div><p>
     The following code sample shows an extract of the audit log after the first
     reconciliation operation in Sample 1.
    </p><pre class="brush: javascript;">{
  "entries": [
    {
      "rootActionId": "d0578abf-f38e-4ede-a7dc-5ee9eaa8ce53",
      "messageDetail": null,
      "message": "Reconciliation initiated by openidm-admin",
      "timestamp": "2013-05-08T07:58:33.296Z",
      "reconId": "5cf09dfa-e85c-4d52-ab6c-8ba7c2e3d34f",
      "entryType": "start",
      "_id": "11381e20-3679-469d-a71c-c557c2bd091e",
      "status": "SUCCESS",
      "exception": "",
      "mapping": "systemXmlfileAccounts_managedUser"
    },
    {
      "messageDetail": null,
      "rootActionId": "d0578abf-f38e-4ede-a7dc-5ee9eaa8ce53",
      "situation": "ABSENT",
      "actionId": "86995423-8a43-4fc7-9c3c-9e450e0234cb",
      "targetObjectId": "managed/user/scarter",
      "action": "CREATE",
      "entryType": "",
      "_id": "9f59bb8a-31c6-41af-8f27-02094391ba0c",
      "reconId": "5cf09dfa-e85c-4d52-ab6c-8ba7c2e3d34f",
      "status": "SUCCESS",
      "exception": "",
      "reconciling": "source",
      "ambiguousTargetObjectIds": "",
      "timestamp": "2013-05-08T07:58:33.791Z",
      "message": null,
      "sourceObjectId": "system/xmlfile/account/scarter"
    },
    {
      "messageDetail": null,
      "rootActionId": "d0578abf-f38e-4ede-a7dc-5ee9eaa8ce53",
      "situation": "ABSENT",
      "actionId": "dea9b5c5-7a75-4cab-b8e4-176bea0a94a6",
      "targetObjectId": "managed/user/bjensen",
      "action": "CREATE",
      "entryType": "",
      "_id": "4fd285ef-a409-4875-abd0-5d70965fe172",
      "reconId": "5cf09dfa-e85c-4d52-ab6c-8ba7c2e3d34f",
      "status": "SUCCESS",
      "exception": "",
      "reconciling": "source",
      "ambiguousTargetObjectIds": "",
      "timestamp": "2013-05-08T07:58:33.793Z",
      "message": null,
      "sourceObjectId": "system/xmlfile/account/bjensen"
      },
      {
        "rootActionId": "d0578abf-f38e-4ede-a7dc-5ee9eaa8ce53",
        "messageDetail": {
          "ended": "2013-05-08T07:58:33.813Z",
          "started": "2013-05-08T07:58:33.294Z",
          "situationSummary": {
            "SOURCE_MISSING": 0,
            "FOUND": 0,
            "SOURCE_IGNORED": 0,
            "UNQUALIFIED": 0,
            "UNASSIGNED": 0,
            "TARGET_IGNORED": 0,
            "CONFIRMED": 0,
            "AMBIGUOUS": 0,
            "ABSENT": 2,
            "MISSING": 0
          },
          "progress": {
            "links": {
              "created": 2,
              "existing": {
                "total": "0",
                "processed": 0
              }
            },
            "target": {
              "created": 2,
              "existing": {
                "total": "0",
                "processed": 0
              }
            },
            "source": {
              "existing": {
                "total": "2",
                "processed": 2
              }
            }
          },
          "stageDescription": "reconciling target entries",
          "stage": "ACTIVE_RECONCILING_TARGET",
          "state": "ACTIVE",
          "mapping": "systemXmlfileAccounts_managedUser"
        },
        "message": "SOURCE_IGNORED: 0 MISSING: 0 FOUND: 0 AMBIGUOUS: 0 UNQUALIFIED: 0
           CONFIRMED: 0 SOURCE_MISSING: 0 ABSENT: 2 TARGET_IGNORED: 0 UNASSIGNED: 0 ",
        "timestamp": "2013-05-08T07:58:33.813Z",
        "reconId": "5cf09dfa-e85c-4d52-ab6c-8ba7c2e3d34f",
        "entryType": "summary",
        "_id": "a8a81f9f-fa8f-49f4-a0d6-c88b5fc4be2a",
        "status": "SUCCESS",
        "exception": "",
        "mapping": "systemXmlfileAccounts_managedUser"
      }
    ]
}    </pre><p>
     Most of the fields in this audit log are self-explanatory. Each distinct
     reconciliation operation is identified by its <code class="literal">reconId</code>.
     Each entry in the log is identified by a unique <code class="literal">_id</code>. The
     first log entry indicates the status for the complete reconciliation
     operation. Successive entries indicate the status for each record affected
     by the reconciliation.
    </p><p>
     To obtain information on a specific audit log entry, include its entry
     <code class="literal">_id</code> in the URL. For example:
    </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/audit/recon/9f59bb8a-31c6-41af-8f27-02094391ba0c"</pre></div><p>
     The following sample output shows the results of a read operation on a
     specific reconciliation audit entry.
    </p><pre class="brush: javascript;">{
 "targetObjectId": "managed/user/5b9b75e8-2667-4040-a50d-7a644922f072",
 "sourceObjectId": "system/ldap/account/uid=jdoe,ou=People,dc=example,dc=com",
 "situation": "CONFIRMED",
 "reconciling": "source",
 "ambiguousTargetObjectIds": "",
 "action": "UPDATE",
 "actionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
 "exception": "",
 "_id": "88802a56-8be9-43bf-aaf9-d861820f3e39",
 "entryType": "",
 "timestamp": "2014-03-06T06:59:14.637Z",
 "reconId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
 "rootActionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
 "status": "SUCCESS",
 "message": null,
 "messageDetail": null
}   </pre><p>
     To query the audit log for a particular reconciliation operation, use the
     <code class="literal">audit-by-recon-id</code> keyword, specifying the reconciliation
     ID, as follows:
    </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/audit/recon?_queryId=audit-by-recon-id&amp;reconId=&lt;reconID&gt;"</pre></div><p>
     Output similar to the following is returned, for the specified
     reconciliation operation:
    </p><pre class="brush: javascript;">{
 "remainingPagedResults": -1,
 "pagedResultsCookie": null,
 "resultCount": 5,
 "result": [
   {
     "mapping": "systemLdapAccounts_managedUser",
     "exception": "",
     "_id": "e8932aef-31ad-43e8-ab5a-c997b247ab9d",
     "entryType": "summary",
     "timestamp": "2014-03-06T06:59:14.691Z",
     "reconId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
     "rootActionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
     "status": "SUCCESS",
     "message": "SOURCE_IGNORED: 0 MISSING: 0 FOUND: 0 AMBIGUOUS: 0 UNQUALIFIED: 0
         CONFIRMED: 1 SOURCE_MISSING: 0 ABSENT: 0 TARGET_IGNORED: 0 UNASSIGNED: 2 ",
     "messageDetail": {
       "stage": "ACTIVE_RECONCILING_TARGET",
       "stageDescription": "reconciling target entries",
       "ended": "2014-03-06T06:59:14.691Z",
       "started": "2014-03-06T06:59:14.353Z",
       "mapping": "systemLdapAccounts_managedUser",
       "state": "ACTIVE",
       "situationSummary": {
         "SOURCE_MISSING": 0,
         "FOUND": 0,
         "SOURCE_IGNORED": 0,
         "UNQUALIFIED": 0,
         "UNASSIGNED": 2,
         "TARGET_IGNORED": 0,
         "CONFIRMED": 1,
         "AMBIGUOUS": 0,
         "ABSENT": 0,
         "MISSING": 0
       },
       "progress": {
         "links": {
           "created": 0,
           "existing": {
             "processed": 1,
             "total": "1"
           }
         },
       "source": {
         "existing": {
           "processed": 1,
           "total": "1"
         }
       },
       "target": {
         "created": 0,
         "existing": {
           "processed": 3,
           "total": "3"
         }
       }
     }
   }
 },
 {
   "targetObjectId": "managed/user/e8b93d84-5295-4286-b951-cea07550a331",
   "sourceObjectId": null,
   "situation": "UNASSIGNED",
   "reconciling": "target",
   "ambiguousTargetObjectIds": null,
   "action": "IGNORE",
   "actionId": null,
   "exception": "",
   "_id": "7878e924-0aa6-46a9-8d42-716eae098121",
   "entryType": "",
   "timestamp": "2014-03-06T06:59:14.674Z",
   "reconId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "rootActionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "status": "SUCCESS",
   "message": null,
   "messageDetail": null
 },
 {
   "targetObjectId": "managed/user/0e4cfe5e-3d9d-4d74-acf4-596f610eda5a",
   "sourceObjectId": null,
   "situation": "UNASSIGNED",
   "reconciling": "target",
   "ambiguousTargetObjectIds": null,
   "action": "IGNORE",
   "actionId": null,
   "exception": "",
   "_id": "795d1616-9ec7-44c7-80f5-bc7c566bd2fe",
   "entryType": "",
   "timestamp": "2014-03-06T06:59:14.653Z",
   "reconId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "rootActionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "status": "SUCCESS",
   "message": null,
   "messageDetail": null
 },
 {
   "targetObjectId": "managed/user/5b9b75e8-2667-4040-a50d-7a644922f072",
   "sourceObjectId": "system/ldap/account/uid=jdoe,ou=People,dc=example,dc=com",
   "situation": "CONFIRMED",
   "reconciling": "source",
   "ambiguousTargetObjectIds": "",
   "action": "UPDATE",
   "actionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "exception": "",
   "_id": "88802a56-8be9-43bf-aaf9-d861820f3e39",
   "entryType": "",
   "timestamp": "2014-03-06T06:59:14.637Z",
   "reconId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "rootActionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "status": "SUCCESS",
   "message": null,
   "messageDetail": null
 },
 {
   "mapping": "systemLdapAccounts_managedUser",
   "exception": "",
   "_id": "91c00e7f-1975-4f68-bfba-7740e8f05ec5",
   "entryType": "start",
   "timestamp": "2014-03-06T06:59:14.354Z",
   "reconId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "rootActionId": "a0c8ea66-8798-451d-a55c-9d4b95f0941e",
   "status": "SUCCESS",
   "message": "Reconciliation initiated by openidm-admin",
   "messageDetail": null
 }
]
}</pre><p>
     To query the audit log for a specific reconciliation situation, use the
     <code class="literal">audit-by-recon-id-situation</code> keyword, specifying the
     reconciliation ID and the situation that you want to query. For example,
     the following query returns all ABSENT records found during the specified
     reconciliation operation:
    </p><div class="screen"><pre>
$ <strong>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/audit/recon?_queryId=audit-by-recon-id-situation&amp;situation=ABSENT&amp;reconId=fd2a59df-1fcd-444d-97ca-2c8a7ec6dc6c"</strong>
    </pre></div><p>
     Output similar to the following is returned, with one entry for each record
     that matches the situation queried:
    </p><pre class="brush: javascript;">{
  "result": [
    {
      "messageDetail": null,
      "rootActionId": "3c098d6f-a5e5-483c-a8ce-82911a10b0a9",
      "situation": "ABSENT",
      "actionId": "1a391fe8-201b-4f59-ad05-92ee804488a8",
      "targetObjectId": "managed/user/scarter",
      "action": "CREATE",
      "entryType": "",
      "_id": "6dc0a18a-826d-487d-a29f-5cd8d2f55465",
      "reconId": "1ef8e7b6-33dc-4f92-810a-b51913508a68",
      "status": "SUCCESS",
      "exception": "",
      "reconciling": "source",
      "ambiguousTargetObjectIds": "",
      "timestamp": "2013-05-14T08:20:41.763Z",
      "message": null,
      "sourceObjectId": "system/xmlfile/account/scarter"
    },
    {
      "messageDetail": null,
      "rootActionId": "3c098d6f-a5e5-483c-a8ce-82911a10b0a9",
      "situation": "ABSENT",
      "actionId": "0aaba292-1dd3-4e98-a0e2-04bec9ae5209",
      "targetObjectId": "managed/user/bjensen",
      "action": "CREATE",
      "entryType": "",
      "_id": "1cda457e-54e2-451b-8a40-ef93dec7e60c",
      "reconId": "1ef8e7b6-33dc-4f92-810a-b51913508a68",
      "status": "SUCCESS",
      "exception": "",
      "reconciling": "source",
      "ambiguousTargetObjectIds": "",
      "timestamp": "2013-05-14T08:20:41.760Z",
      "message": null,
      "sourceObjectId": "system/xmlfile/account/bjensen"
    }
  ]
}   </pre><p>
     The activity logs track all operations on internal (managed) and external
     (system) objects. Entries in the activity log contain identifiers for the
     reconciliation or synchronization action that triggered the activity, and
     for the original caller and the relationships between related actions.
    </p><p>
     You can access the activity logs over REST with the following call:
    </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/audit/activity"</pre></div><p>
     The following extract of the activity log shows the last entry in the log,
     which was a password change for user bjensen.
    </p><pre class="brush: javascript;">{
   "entries": [
   ...
   },
     "before": null,
     "requester": "openidm-admin",
     "parentActionId": "c2c102bc-7b32-4020-b5aa-9a7d63652cb6",
     "_id": "bbaff1e0-923b-48f0-b053-b1614cbb3647",
     "activityId": "c2c102bc-7b32-4020-b5aa-9a7d63652cb6",
     "timestamp": "2014-03-13T16:20:54.811Z",
     "action": "CREATE",
     "message": "create",
     "objectId": "managed/user/4f2f5eea-918a-4ef1-9244-be41dcf128a4",
     "rev": "1",
     "rootActionId": "c2c102bc-7b32-4020-b5aa-9a7d63652cb6"
   },
   {
     "passwordChanged": true,
     "changedFields": [
     "/password"
   ],
     "status": "SUCCESS",
     "after": {
       "securityAnswer": {
         "$crypto": {
           "value": {
             "key": "openidm-sym-default",
             "iv": "8CvlA6rWN03MAhLSKJmbvw==",
             "cipher": "AES/CBC/PKCS5Padding",
             "data": "oJBTrrX+wFAygFZkLuGPrhB/jAIICcdIBuCX1eEbpS0="
           },
           "type": "x-simple-encryption"
         }
       },
   ...
  </pre><p>
     To return activity information for a specific action, include the
     <code class="literal">_id</code> of the action in the endpoint, for example:
    </p><div class="screen"><pre>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/audit/activity/22ef6d20-bd84-4267-9db8-745825a46ad1"</pre></div><p>
     Results similar to the following are returned:
    </p><pre class="brush: javascript;">{
  "passwordChanged": true,
  "changedFields": [
    "/password"
  ],
  "status": "SUCCESS",
  "after": {
    "securityAnswer": {
      "$crypto": {
      "value": {
        "key": "openidm-sym-default",
        "iv": "HpsyTtTXc2pfNrXlYbro7Q==",
        "cipher": "AES/CBC/PKCS5Padding",
        "data": "0M6O7geNjalJ7e0EGSG9B90eaeF8zJuogdL74hcAIRg="
      },
      "type": "x-simple-encryption"
    }
  },
  "userName": "bjensen@example.com",
  "stateProvince": "",
  "postalAddress": "",
  "effectiveAssignments": {},
  "roles": "openidm-authorized",
  "telephoneNumber": "1234567",
  "accountStatus": "active",
  "password": {
    "$crypto": {
      "value": {
        "key": "openidm-sym-default",
        "iv": "dkRjURz761HaObBuLl+EkA==",
        "cipher": "AES/CBC/PKCS5Padding",
        "data": "9chNPUlXotHy195ERj6vlg=="
      },
      "type": "x-simple-encryption"
    }
  },
  "effectiveRoles": [
    "openidm-authorized"
  ],
  "givenName": "Barbara",
  "lastPasswordAttempt": "Thu Mar 13 2014 07:23:12 GMT-0800 (GMT-08:00)",
  "address2": "",
  "passwordAttempts": "0",
  "sn": "Jensen",
  "mail": "bjensen@example.com",
  "securityQuestion": "1",
  "city": "",
  "country": "",
  "_rev": "7",
  "lastPasswordSet": "",
  "postalCode": "",
  "_id": "bjensen",
  "description": "Created By XML1"
},
  "before": {
  "securityAnswer": "Some security answer",
  "userName": "bjensen@example.com",
  "stateProvince": "",
  "postalAddress": "",
  "roles": "openidm-authorized",
  "telephoneNumber": "1234567",
  "password": {
    "$crypto": {
      "value": {
        "key": "openidm-sym-default",
        "iv": "bqhRyLW1lI+KZROcpgyukg==",
        "cipher": "AES/CBC/PKCS5Padding",
        "data": "qO8A76GqNqftVVwOlasyPw=="
      },
      "type": "x-simple-encryption",
    "securityQuestion": "1",
  "givenName": "Barbara",
  "address2": "",
  "lastPasswordAttempt": "Thu Mar 13 2014 07:23:12 GMT-0800 (GMT-08:00)",
  "passwordAttempts": "0",
  "sn": "Jensen",
  "mail": "bjensen@example.com",
  "country": "",
  "city": "",
  "_rev": "7",
  "lastPasswordSet": "",
  "postalCode": "",
  "_id": "bjensen",
  "description": "Created By XML1",
  "accountStatus": "active"
},
"requester": "openidm-admin",
"parentActionId": "71ddeed8-9006-4578-b869-13e15a3ce6b5",
"_id": "ee88adb8-3329-4f81-a8f2-d9c8e0fbf72b",
"activityId": "71ddeed8-9006-4578-b869-13e15a3ce6b5",
"timestamp": "2014-03-13T16:21:27.086Z",
"action": "UPDATE",
"message": "update",
"objectId": "managed/user/bjensen",
"rev": "7",
"rootActionId": "71ddeed8-9006-4578-b869-13e15a3ce6b5"
}    </pre><p>
     Each action in the activity log has a <code class="literal">rootActionId</code> and a
     <code class="literal">parentActionId</code>. The <code class="literal">rootActionId</code> is
     the ID that was assigned to the incoming or initiating request. The
     <code class="literal">parentActionId</code> is the ID that is associated with the
     overall action. So, for example, if an HTTP request invokes a script that
     changes a user's password, the HTTP request is assigned the
     <code class="literal">rootActionId</code> and the action taken by the script is
     assigned the <code class="literal">parentActionId</code>. You can query the activity
     log for the details of a specific action by including the
     <code class="literal">parentActionId</code> in the query. For example:
    </p><div class="screen"><pre><strong>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/audit/activity?_queryId=audit-by-activity-parent-action&amp;parentActionId=0aaba292-1dd3-4e98-a0e2-04bec9ae5209"</strong></pre></div><p>
     The following sample output shows the result of a query that requests
     details of the password change for bjensen.
    </p><pre class="brush: javascript;">{
  "remainingPagedResults": -1,
  "pagedResultsCookie": null,
  "resultCount": 2,
  "result": [
    {
      "rootActionId": "71ddeed8-9006-4578-b869-13e15a3ce6b5",
      "changedFields": [
        "/password"
    ],
      "action": "UPDATE",
      "objectId": "managed/user/bjensen",
      "before": {
        "securityAnswer": "Some security answer",
        "userName": "bjensen@example.com",
        "stateProvince": "",
        "postalAddress": "",
        "roles": "openidm-authorized",
        "telephoneNumber": "1234567",
        "password": "CAngetin1",
        "securityQuestion": "1",
        "givenName": "Barbara",
        "address2": "",
        "lastPasswordAttempt": "Thu Mar 13 2014 07:23:12 GMT-0800 (GMT-08:00)",
        "passwordAttempts": "0",
        "sn": "Jensen",
        "mail": "bjensen@example.com",
        "country": "",
        "city": "",
        "_rev": "7",
        "lastPasswordSet": "",
        "postalCode": "",
        "_id": "bjensen",
        "description": "Created By XML1",
        "accountStatus": "active"
      },
      "status": "SUCCESS",
      "_rev": "1",
      "_id": "ee88adb8-3329-4f81-a8f2-d9c8e0fbf72b",
      "parentActionId": "71ddeed8-9006-4578-b869-13e15a3ce6b5",
      "timestamp": "2014-03-13T16:21:27.086Z",
      "message": "update",
      "activityId": "71ddeed8-9006-4578-b869-13e15a3ce6b5",
      "after": {
        "securityAnswer": {
          "$crypto": {
            "value": {
              "key": "openidm-sym-default",
              "iv": "HpsyTtTXc2pfNrXlYbro7Q==",
              "cipher": "AES/CBC/PKCS5Padding",
              "data": "0M6O7geNjalJ7e0EGSG9B90eaeF8zJuogdL74hcAIRg="
            },
            "type": "x-simple-encryption"
          }
        },
        "userName": "bjensen@example.com",
        "stateProvince": "",
        "postalAddress": "",
        "effectiveAssignments": {},
        "roles": "openidm-authorized",
        "telephoneNumber": "1234567",
        "accountStatus": "active",
        "password": {
          "$crypto": {
            "value": {
              "key": "openidm-sym-default",
              "iv": "dkRjURz761HaObBuLl+EkA==",
              "cipher": "AES/CBC/PKCS5Padding",
              "data": "9chNPUlXotHy195ERj6vlg=="
          },
        "type": "x-simple-encryption"
      }
    },
    "effectiveRoles": [
       "openidm-authorized"
    ],
    "givenName": "Barbara",
    "lastPasswordAttempt": "Thu Mar 13 2014 07:23:12 GMT-0800 (GMT-08:00)",
    "address2": "",
    "passwordAttempts": "0",
    "sn": "Jensen",
    "mail": "bjensen@example.com",
    "securityQuestion": "1",
    "city": "",
    "country": "",
    "_rev": "7",
    "lastPasswordSet": "",
    "postalCode": "",
    "_id": "bjensen",
    "description": "Created By XML1"
  },
  "rev": "7",
  "requester": "openidm-admin",
  "passwordChanged": true
  }
 ]
}</pre><div class="note"><h3 class="title">Note</h3><p>
      For audit logs in the repository, you can define custom queries using the
      parameterized query mechanism. For more information, see the section on
      <a href="../../integrators-guide/index/chap-data.html#parameterized-queries" class="link"><em class="citetitle">Parameterized
      Queries</em></a>.
     </p></div><p>
     For more information about the entries in these logs, see the chapter that
     covers <a href="../../integrators-guide/index/chap-auditing.html" class="link"><em class="citetitle">Using Audit
     Logs</em></a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="livesync-retry-strategy"></a>11.8.&nbsp;Configuring the LiveSync Retry Policy</h2></div></div></div><p>
    OpenIDM enables you to specify what should happen if a LiveSync operation
    reports a failure for an operation. By configuring the LiveSync retry
    policy, you can specify how many times a failed modification should be
    reattempted and what should happen in the event that the modification is
    unsuccessful after the specified number of attempts. If no retry policy is
    configured, OpenIDM reattempts the change an infinite number of times, until
    the change is successful. This behavior can increase data consistency in the
    case of transient failures (for example, when the connection to the database
    is temporarily lost). However, in situations where the cause of the failure
    is permanent (for example, if the change does not meet certain policy
    requirements) the change will never succeed, regardless of the number of
    attempts. In this case, the infinite retry behavior can effectively block
    subsequent LiveSync operations from starting.
   </p><p>
    Generally, a scheduled reconciliation operation will eventually force
    consistency. However, to prevent repeated retries that block the LiveSync
    mechanism, you should restrict the number of times OpenIDM reattempts the
    same modification. You can then specify what OpenIDM does with failed
    LiveSync changes. The failed modification can be stored in a "dead letter
    queue", discarded, or reapplied. Alternatively, an administrator can be
    notified of the failure by email or by some other means. This behavior can
    be scripted. The default configuration, in the samples provided with
    OpenIDM, is to retry a failed modification five times, and then to log and
    ignore the failure.
   </p><p>
    The LiveSync retry policy is configured in the connector configuration file
    (<code class="filename">provisioner.openicf-*.json</code>). The sample connector
    configuration files have a retry policy defined as follows:
   </p><pre class="brush: javascript;">
"syncFailureHandler" : {
  "maxRetries" : 5,
  "postRetryAction" : "logged-ignore"
},
   </pre><p>
    The <code class="literal">maxRetries</code> field specifies the number of attempts
    that OpenIDM should make to process the failed modification. The value of
    this property must be a positive integer, or <code class="literal">-1</code>. A value
    of zero indicates that failed modifications should not be reattempted. In
    this case, the post retry action is executed immediately when a LiveSync
    operation fails. A value of <code class="literal">-1</code> (or omitting the
    <code class="literal">maxRetries</code> property, or the entire
    <code class="literal">syncFailureHandler</code> from the configuration) indicates that
    failed modifications should be retried an infinite number of times. In this
    case, no post retry action is executed.
   </p><p>
    The default retry policy relies on the scheduler, or whatever invokes the
    LiveSync operation. Therefore, if retries are enabled and a LiveSync
    modification fails, OpenIDM will retry the modification the next time that
    LiveSync is invoked.
   </p><p>
    The <code class="literal">postRetryAction</code> field indicates what action OpenIDM
    should take in the event that the maximum number of retries has been reached
    (or if <code class="literal">maxRetries</code> has been set to zero). The post retry
    action can be one of the following:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      <code class="literal">logged-ignore</code> indicates that OpenIDM should ignore the
      failed modification, and log its occurrence.
     </p></li><li class="listitem"><p>
      <code class="literal">dead-letter-queue</code> indicates that OpenIDM should save
      the details of the failed modification in a table in the repository
      (accessible over REST at
      <code class="literal">repo/synchronisation/deadLetterQueue/<em class="replaceable"><code>provisioner-name</code></em></code>).
     </p></li><li class="listitem"><p>
      <code class="literal">script</code> specifies a custom script that should be
      executed when the maximum number of retries has been reached. For
      information about using custom scripts in the configuration, see the
      <a href="../../integrators-guide/index/appendix-scripting.html" class="link"><em class="citetitle">Scripting
      Reference</em></a>.
     </p><p>
      In addition to the regular objects described in the Scripting Reference,
      the following objects are available in the script scope:
     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
        <code class="literal">syncFailure</code>
       </p><p>
        Provides details about the failed record. The structure of the
        <code class="literal">syncFailure</code> object is as follows:
       </p><pre class="brush: javascript;">
"syncFailure" :
  {
    "token" : the ID of the token,
    "systemIdentifier" : a string identifier that matches the "name" property in
                         provisioner.openicf.json,
    "objectType" : the object type being synced, one of the keys in the
                   "objectTypes" property in provisioner.openicf.json,
    "uid" : the UID of the object (for example uid=joe,ou=People,dc=example,dc=com),
    "failedRecord", the record that failed to synchronize
  },
       </pre><p>
        To access these fields, include
        <code class="literal">syncFailure.<em class="replaceable"><code>fieldname</code></em></code> in
        your script.
       </p></li><li class="listitem"><p>
        <code class="literal">failureCause</code>
       </p><p>
        Provides the exception that caused the original LiveSync failure.
       </p></li><li class="listitem"><p>
        <code class="literal">failureHandlers</code>
       </p><p>
        OpenIDM currently provides two synchronization failure handlers "out of
        the box". <code class="literal">loggedIgnore</code> indicates that the failure
        should be logged, after which no further action should be taken.
        <code class="literal">deadLetterQueue</code> indicates that the failed record
        should be written to a specific table in the repository, where further
        action can be taken. To invoke one of the internal failure handlers from
        your script, use a call similar to the following (shown here for
        JavaScript):
       </p><div class="screen"><pre>failureHandlers.deadLetterQueue.invoke(syncFailure, failureCause);</pre></div></li></ul></div><p>
      Two sample scripts are provided in
      <code class="filename">path/to/openidm/samples/syncfailure/script</code>, one that
      logs failures, and one that sends them to the dead letter queue in the
      repository.</p></li></ul></div><p>
     The following sample provisioner configuration file extract shows a
     LiveSync retry policy that specifies a maximum of four retries before the
     failed modification is sent to the dead letter queue.
    </p><pre class="brush: javascript;">
...
"connectorName" : "org.identityconnectors.ldap.LdapConnector"
    },
    "syncFailureHandler" : {
        "maxRetries" : 4,
        "postRetryAction" : dead-letter-queue
    },
    "poolConfigOption" : {
...
    </pre><p>
     In the case of a failed modification, a message similar to the following is
     output to the log file:
    </p><div class="screen"><pre>INFO: sync retries = 1/4, retrying</pre></div><p>
     OpenIDM reattempts the modification, the specified number of times. If the
     modification is still unsuccessful, a message similar to the following is
     logged:
    </p><div class="screen"><pre>INFO: sync retries = 4/4, retries exhausted
Jul 19, 2013 11:59:30 AM
    org.forgerock.openidm.provisioner.openicf.syncfailure.DeadLetterQueueHandler invoke
INFO: uid=jdoe,ou=people,dc=example,dc=com saved to dead letter queue
    </pre></div><p>
     The log message indicates the entry for which the modification failed
     (<code class="literal">uid=jdoe</code>, in this example).
    </p><p>You can view the failed modification in the dead letter queue, over
     the REST interface, as follows:
    </p><div class="screen"><pre>$ <strong>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/repo/synchronisation/deadLetterQueue/ldap?_queryId=query-all-ids"</strong>
     <em>{
       "query-time-ms": 2,
       "result":
       [
           {
               "_id": "4",
               "_rev": "0"
           }
       ],
       "conversion-time-ms": 0
    }</em></pre></div><p>
     To view the details of a specific failed modification, include its ID in
     the URL:
    </p><div class="screen"><pre>$ <strong>curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --request GET \
 "https://localhost:8443/openidm/repo/synchronisation/deadLetterQueue/ldap/4"</strong>
     <em>{
  "objectType": "account",
  "systemIdentifier": "ldap",
  "failureCause": "org.forgerock.openidm.sync.SynchronizationException:
            org.forgerock.openidm.objset.ConflictException:
            org.forgerock.openidm.sync.SynchronizationException:
            org.forgerock.openidm.script.ScriptException:
            ReferenceError: \"bad\" is not defined.
            (PropertyMapping/mappings/0/properties/3/condition#1)",
  "token": 4,
  "failedRecord": "<em><strong>complete record, in xml format</strong></em>"
  "uid": "uid=jdoe,ou=people,dc=example,dc=com",
  "_rev": "0",
  "_id": "4"
}   </em></pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="handling-sync"></a>11.9.&nbsp;Synchronization Situations and Actions</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#sync-situations">11.9.1. Synchronization Situations</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#source-reconciliation">11.9.2. Source Reconciliation</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#target-reconciliation">11.9.3. Target Reconciliation</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#autosync-and-livesync">11.9.4. Situations Specific to Automatic Synchronization and LiveSync</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#sync-actions">11.9.5. Synchronization Actions</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#script-actions">11.9.6. Providing a Script as an Action</a></span></dt></dl></div><a class="indexterm" name="d0e9185"></a><a class="indexterm" name="d0e9190"></a><p>
   During synchronization, OpenIDM categorizes objects according to their
   <em class="firstterm">situation</em>. Situations are characterized by whether an
   object exists on a source or target system, whether OpenIDM has registered a
   link between the source object and the target object, and whether the object
   is considered <em class="firstterm">valid</em>, as assessed by the
   <code class="literal">validSource</code> and <code class="literal">validTarget</code> scripts.
   OpenIDM then takes a specific action, depending on the situation.
  </p><p>
   You can define actions for particular situations in the
   <code class="literal">policies</code> section of a synchronization mapping, as shown in
   the following excerpt.
  </p><pre class="brush: javascript;">
{
    "policies": [
        {
            "situation": "CONFIRMED",
            "action": "UPDATE"
        },
        {
            "situation": "FOUND",
            "action": "UPDATE"
        },
        {
            "situation": "ABSENT",
            "action": "CREATE"
        },
        {
            "situation": "AMBIGUOUS",
            "action": "EXCEPTION"
        },
        {
            "situation": "MISSING",
            "action": "EXCEPTION"
        },
        {
            "situation": "UNQUALIFIED",
            "action": "DELETE"
        },
        {
            "situation": "UNASSIGNED",
            "action": "EXCEPTION"
        }
    ]
}</pre><p>
   If you do not define a policy for a particular situation, OpenIDM takes the
   <em class="firstterm">default action</em> for the situation.
  </p><p>
   The following sections describe the possible situations and their default
   corresponding actions.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sync-situations"></a>11.9.1.&nbsp;Synchronization Situations</h3></div></div></div><div class="orderedlist"><p>
     OpenIDM performs a reconciliation operation in two phases:
    </p><ol class="orderedlist" type="1"><li class="listitem"><p>
      <em class="firstterm">Source reconciliation</em>, where OpenIDM accounts for
      source objects and associated links, based on the configured mapping.
     </p></li><li class="listitem"><p>
      <em class="firstterm">Target reconciliation</em>, where OpenIDM iterates over
      the target objects that were not processed in the first phase.
     </p></li></ol></div><div class="orderedlist"><p>
     During the source reconciliation phase, OpenIDM builds three lists,
     assigning values to the objects to reconcile.
    </p><ol class="orderedlist" type="1"><li class="listitem"><p>
      All valid objects from the source
     </p><p>
      OpenIDM assigns valid source objects <code class="literal">qualifies=1</code>.
      Invalid objects, including those that were not found in the source system,
      and those that were filtered out by the script specified in the
      <code class="literal">validSource</code> property, are assigned
      <code class="literal">qualifies=0</code>.
     </p></li><li class="listitem"><p>
      All records from the appropriate links table
     </p><p>
      Objects that have a corresponding link in the links table of the
      repository are assigned <code class="literal">link=1</code>. Objects that do not
      have a corresponding link are assigned <code class="literal">link=0</code>.
     </p></li><li class="listitem"><p>
      All valid objects on the target system
     </p><p>
      Objects that are found in the target system are assigned
      <code class="literal">target=1</code>. Objects that are not found in the target
      system are assigned <code class="literal">target=0</code>.
     </p></li></ol></div><div class="variablelist"><p>
     Based on the values assigned to objects during source reconciliation,
     OpenIDM assigns situations, listed here with default and appropriate
     alternative actions.
    </p><dl class="variablelist"><dt><span class="term">"CONFIRMED" (qualifies=1, link=1, target=1)</span></dt><dd><p>
       The source object qualifies for a target object, and a link to an
       existing target object was found. This situation is detected during
       change events and during reconciliation.
      </p><p>
       Default action: <code class="literal">UPDATE</code> the target object.
      </p><p>
       Other valid actions: <code class="literal">IGNORE, REPORT, NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">"FOUND" (qualifies=1, link=0, target=1)</span></dt><dd><p>
       The source object qualifies for a target object and there is no link to
       an existing target object. There is a single target object, that
       correlates with this source object, according to the logic in the
       correlation query. This situation is detected during change events and
       reconciliation.
      </p><p>
       Default action: <code class="literal">UPDATE</code> the target object.
      </p><p>
       Other valid actions: <code class="literal">EXCEPTION, IGNORE, REPORT,
       NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">"FOUND_ALREADY_LINKED" (qualifies=1, link=1, target=1)</span></dt><dd><p>
       The source object qualifies for a target object and there is no link from
       that source object to an existing target object. There is a single target
       object, that correlates with this source object, according to the logic
       in the correlation query, but that target object is already linked to a
       different source object. This situation is detected during change events
       and reconciliation.
      </p><p>
       Default action: log an <code class="literal">EXCEPTION</code>.
      </p><p>
       Other valid actions: <code class="literal">IGNORE, REPORT, NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">"ABSENT" (qualifies=1, link=0, target=0)</span></dt><dd><p>
       The source object qualifies for a target object, there is no link to an
       existing target object, and there is no correlated target object found.
       This situation is detected during change events and reconciliation.
      </p><p>
       Default action: <code class="literal">CREATE</code> a target object.
      </p><p>
       Other valid actions: <code class="literal">EXCEPTION, IGNORE, REPORT, NOREPORT, ASYNC
      </code>
      </p></dd><dt><span class="term">"AMBIGUOUS" (qualifies=1, link=0, target&gt;1)</span></dt><dd><p>
       The source object qualifies for a target object, there is no link to an
       existing target object, but there is more than one correlated target
       object (that is, more than one possible match on the target system). This
       situation is detected during source object changes and reconciliation.
      </p><p>
       Default action: log an <code class="literal">EXCEPTION</code>.
      </p><p>
       Other valid actions: <code class="literal">IGNORE, REPORT, NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">"MISSING" (qualifies=1, link=1, target=0)</span></dt><dd><p>
       The source object qualifies for a target object, and there is a link to a
       target object, but the target object is missing. This situation is
       detected during reconciliation operations and during source object changes.
      </p><p>
       Default action: log an <code class="literal">EXCEPTION</code>.
      </p><p>
       Other valid actions: <code class="literal">CREATE, UNLINK, IGNORE, REPORT, NOREPORT.
      ASYNC</code>
      </p></dd><dt><span class="term">"UNQUALIFIED" (qualifies=0, link=0 or 1, target=1 or &gt;1)</span></dt><dd><p>
       The source object is unqualified (by the "validSource" script). One or
       more target objects are found through the correlation logic. This
       situation is detected during change events and reconciliation.
      </p><p>
       Default action: <code class="literal">DELETE</code> the target object or objects.
      </p><p>
       Other valid actions: <code class="literal">EXCEPTION, IGNORE, REPORT, NOREPORT,
      ASYNC</code>
      </p></dd><dt><span class="term">"TARGET_IGNORED" (qualifies=0, link=0 or 1, target=1)</span></dt><dd><p>
       The source object is unqualified (by the "validSource" script). One or
       more target objects are found through the correlation logic. This
       situation is detected only during source object changes.
      </p><p>
       It is different from "UNQUALIFIED", based on the status of the link and
       target. If there is a link, the target is not valid. If there is no link
       and exactly one target, that target is not valid.
      </p><p>
       Default action: <code class="literal">IGNORE</code> the target object until the
       next full reconciliation operation.
      </p><p>
       Other valid actions: <code class="literal">DELETE, UNLINK, EXCEPTION, REPORT,
       NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">"SOURCE_IGNORED" (qualifies=0, link=0, target=0)</span></dt><dd><p>
       The source object is unqualified (by the "validSource" script), no link
       is found, and no correlated target exists. This situation is detected
       during source object changes and reconciliation.
      </p><p>
       Default action: <code class="literal">IGNORE</code> the source object.
      </p><p>
       Other valid actions: <code class="literal">EXCEPTION, REPORT, NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">"LINK_ONLY" (qualifies=n/a, link=1, target=0)</span></dt><dd><p>
       The source may or may not be qualified, a link is found, but no target
       object is found. This situation is detected only during source object
       changes.
      </p><p>
       Default action: Log an <code class="literal">EXCEPTION</code>.
      </p><p>
       Other valid actions: <code class="literal">UNLINK, IGNORE, REPORT, NOREPORT,
       ASYNC</code>
      </p></dd><dt><span class="term">"ALL_GONE" (qualifies=n/a, link=0, cannot-correlate)</span></dt><dd><p>
       The source object has been removed. No link is found. Correlation is not
       possible, for one of the following reasons:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         No previous source value can be found
        </p></li><li class="listitem"><p>
         There is no correlation query
        </p></li><li class="listitem"><p>
         A previous value was found, and a correlation query exists, but no
         corresponding target was found
        </p></li></ul></div><p>This situation is detected only during source object changes.
      </p><p>
       Default action: "IGNORE" the source object.
      </p><p>
       Other valid actions: <code class="literal">EXCEPTION, REPORT, NOREPORT,
      ASYNC</code>
      </p></dd></dl></div><div class="orderedlist"><p>
     During the target reconciliation phase, OpenIDM assigns the following
     values as it iterates through the target objects that were not accounted
     for during the source reconciliation.
    </p><ol class="orderedlist" type="1"><li class="listitem"><p>
      Valid objects from the target
     </p><p>
      OpenIDM assigns valid target objects <code class="literal">qualifies=1</code>.
      Invalid objects, including those that are filtered out by the script
      specified in the <code class="literal">validTarget</code> property, are assigned
      <code class="literal">qualifies=0</code>.
     </p></li><li class="listitem"><p>
      All records from the appropriate links table
     </p><p>
      Objects that have a corresponding link in the links table of the
      repository are assigned <code class="literal">link=1</code>. Objects that do not
      have a corresponding link are assigned <code class="literal">link=0</code>.
     </p></li><li class="listitem"><p>
      All valid objects on the source system
     </p><p>
      Objects that are found in the source system are assigned
      <code class="literal">source=1</code>. Objects that are not found in the source
      system are assigned <code class="literal">source=0</code>.
     </p></li></ol></div><p>
     Based on the values that are assigned to objects during the target
     reconciliation phase, OpenIDM assigns situations, listed here with their
     default actions.
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">"TARGET_IGNORED" (qualifies=0)</span></dt><dd><p>
       During target reconciliation, the target becomes unqualified by the
      "validTarget" script. This situation is detected only during
       reconciliation operations.
      </p><p>
       Default action: <code class="literal">IGNORE</code> the target object.
      </p><p>
       Other valid actions: <code class="literal">DELETE, UNLINK, REPORT, NOREPORT,
      ASYNC</code>
      </p></dd><dt><span class="term">"UNASSIGNED" (qualifies=1, link=0)</span></dt><dd><p>
       A valid target object exists, for which there is no link. This situation
       is detected only during reconciliation operations.
      </p><p>
       Default action: log an <code class="literal">EXCEPTION</code>.
      </p><p>
       Other valid actions: <code class="literal">IGNORE, REPORT, NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">"CONFIRMED" (qualifies=1, link=1, source=1)</span></dt><dd><p>
       The target object qualifies, and a link to a source object exists. This
       situation is detected only during reconciliation operations.
      </p><p>
       Default action: <code class="literal">UPDATE</code> the target object.
      </p><p>
       Other valid actions: <code class="literal">IGNORE, REPORT, NOREPORT</code>
      </p></dd><dt><span class="term">"UNQUALIFIED" (qualifies=0, link=1, source=1, but source does not
     qualify)</span></dt><dd><p>
       The target object is unqualified, (by the "validTarget" script), but
       there is a link to an existing source object, which is also unqualified.
       This situation is detected during change events and reconciliation.
      </p><p>
       Default action: <code class="literal">DELETE</code> the target object.
      </p><p>
       Other valid actions: <code class="literal">UNLINK, EXCEPTION, IGNORE, REPORT,
       NOREPORT, ASYNC</code>
      </p></dd><dt><span class="term">SOURCE_MISSING (qualifies=1, link=1, source=0)</span></dt><dd><p>
       The target object qualifies and a link is found. But the source object is
       missing. This situation is detected during change events and
       reconciliation.
      </p><p>
       Default action: log an "EXCEPTION".
      </p><p>
       Other valid actions: <code class="literal">DELETE, UNLINK, IGNORE, REPORT,
       NOREPORT, ASYNC</code>
      </p></dd></dl></div><p>
    The following sections reiterate in detail how OpenIDM assigns situations
    during each of the two synchronization phases.
   </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="source-reconciliation"></a>11.9.2.&nbsp;Source Reconciliation</h3></div></div></div><p>
    OpenIDM starts reconciliation and LiveSync by reading a list of objects from
    the resource. For reconciliation, the list includes all objects that are
    available through the connector. For LiveSync, the list contains only
    changed objects. The connector can filter objects out of the list, too, by
    using the script specified in the <code class="literal">validSource</code> property.
   </p><p>
    OpenIDM then iterates over the list, checking each entry against the
    <code class="literal">validSource</code> filter, and classifying objects according to
    their situations as described in <a class="xref" href="chap-synchronization.html#sync-situations" title="11.9.1.&nbsp;Synchronization Situations">Section&nbsp;11.9.1, &#8220;Synchronization Situations&#8221;</a>. OpenIDM
    uses the list of links for the current mapping to classify objects. Finally,
    OpenIDM executes the action that is configured for each situation.
   </p><p>
    The following table shows how OpenIDM assigns the appropriate situation
    during source reconciliation, depending on whether a valid source exists
    (Source Qualifies), whether a link exists in the repository (Link Exists),
    and how many target objects are found, based either on links or on the
    results of the correlation query.
   </p><div class="table"><a name="d0e9608"></a><div class="table-title">Table&nbsp;11.1.&nbsp;Resolving Source Reconciliation Situations</div><div class="table-contents"><table summary="Resolving Source Reconciliation Situations" width="100%" border="0"><colgroup><col width="11%" class="c1"><col width="11%" class="c2"><col width="11%" class="c3"><col width="11%" class="c4"><col width="11%" class="c5"><col width="11%" class="c6"><col width="11%" class="c7"><col width="23%" class="c8"></colgroup><thead><tr><th colspan="2" align="left">Source Qualifies?</th><th colspan="2" align="left">Link Exists?</th><th colspan="3" align="left">Target Objects
       Found<a href="#ftn.d0e9628" class="footnote" name="d0e9628"><sup class="footnote">[a]</sup></a></th><th rowspan="2" align="left" valign="top">Situation</th></tr><tr><th>Yes</th><th>No</th><th>Yes</th><th>No</th><th>0</th><th>1</th><th>&gt; 1</th></tr></thead><tbody><tr><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>SOURCE_MISSING</td></tr><tr><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>UNQUALIFIED</td></tr><tr><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>UNQUALIFIED</td></tr><tr><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>TARGET_IGNORED</td></tr><tr><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>UNQUALIFIED</td></tr><tr><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>ABSENT</td></tr><tr><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>FOUND</td></tr><tr><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X<a href="#ftn.d0e9777" class="footnote" name="d0e9777"><sup class="footnote">[b]</sup></a></td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>FOUND_ALREADY_LINKED</td></tr><tr><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>AMBIGUOUS</td></tr><tr><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>MISSING</td></tr><tr><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>CONFIRMED</td></tr></tbody><tbody class="footnotes"><tr><td colspan="8"><div id="ftn.d0e9628" class="footnote"><p><a href="#d0e9628" class="para"><sup class="para">[a] </sup></a>If no link exists for the source object, then
       OpenIDM executes a correlation query. If no previous object is available,
       OpenIDM cannot correlate.</p></div><div id="ftn.d0e9777" class="footnote"><p><a href="#d0e9777" class="para"><sup class="para">[b] </sup></a>A link does exist from the target object but it
        not for this specific source object.</p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="target-reconciliation"></a>11.9.3.&nbsp;Target Reconciliation</h3></div></div></div><p>
    During source reconciliation, OpenIDM cannot detect situations where no
    source object exists, such as the UNASSIGNED situation. When no source
    object exists, OpenIDM detects the situation during the second
    reconciliation phase, target reconciliation. During target reconciliation,
    OpenIDM iterates over all target objects that do not have a representation
    on the source, checking each object against the
    <code class="literal">validTarget</code> filter, determining the appropriate situation,
    and executing the action configured for the situation.
   </p><p>
    The following table shows how OpenIDM assigns the appropriate situation
    during target reconciliation, depending on whether a valid target exists
    (Target Qualifies), whether a link with an appropriate type exists in the
    repository (Link Exists), whether a source object exists (Source Exists),
    and whether the source object qualifies (Source Qualifies). Not all
    situations assigned during source reconciliation are assigned during target
    reconciliation.
   </p><div class="table"><a name="d0e9849"></a><div class="table-title">Table&nbsp;11.2.&nbsp;Resolving Target Reconciliation Situations</div><div class="table-contents"><table summary="Resolving Target Reconciliation Situations" width="100%" border="0"><colgroup><col width="10%" class="c1"><col width="10%" class="c2"><col width="10%" class="c3"><col width="10%" class="c4"><col width="10%" class="c5"><col width="10%" class="c6"><col width="10%" class="c7"><col width="10%" class="c8"><col width="20%" class="c9"></colgroup><thead><tr><th colspan="2" align="left">Target Qualifies?</th><th colspan="2" align="left">Link Exists?</th><th colspan="2" align="left">Source Exists?</th><th colspan="2" align="left">Source Qualifies?</th><th rowspan="2" align="left" valign="top">Situation</th></tr><tr><th>Yes</th><th>No</th><th>Yes</th><th>No</th><th>Yes</th><th>No</th><th>Yes</th><th>No</th></tr></thead><tbody><tr><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>TARGET_IGNORED</td></tr><tr><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>UNASSIGNED</td></tr><tr><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>CONFIRMED</td></tr><tr><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>UNQUALIFIED</td></tr><tr><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>SOURCE_MISSING</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="autosync-and-livesync"></a>11.9.4.&nbsp;Situations Specific to Automatic Synchronization and LiveSync</h3></div></div></div><p>
    Certain situations occur only during automatic synchronization (when OpenIDM
    pushes changes made in the repository out to external systems) and LiveSync
    (when OpenIDM polls external system change logs for changes and updates the
    repository).
   </p><p>
    The following table shows the situations that pertain only to automatic sync
    and LiveSync, when records are <span class="emphasis"><em>deleted</em></span> from the source
    or target resource.
   </p><div class="table"><a name="d0e9997"></a><div class="table-title">Table&nbsp;11.3.&nbsp;Resolving Automatic Sync and LiveSync Delete Situations</div><div class="table-contents"><table summary="Resolving Automatic Sync and LiveSync Delete Situations" width="100%" border="0"><colgroup><col width="11%" class="c1"><col width="11%" class="c2"><col width="11%" class="c3"><col width="11%" class="c4"><col width="11%" class="c5"><col width="11%" class="c6"><col width="11%" class="c7"><col width="23%" class="c8"></colgroup><thead><tr><th colspan="2" align="left">Source Qualifies?</th><th colspan="2" align="left">Link Exists?</th><th colspan="3" align="left">Target Objects Found
        <a href="#ftn.d0e10017" class="footnote" name="d0e10017"><sup class="footnote">[a]</sup></a>
       </th><th rowspan="2" align="left" valign="top">Situation</th></tr><tr><th>Yes</th><th>No</th><th>Yes</th><th>No</th><th>0</th><th>1</th><th>&gt; 1</th></tr></thead><tbody><tr><td>N/A</td><td>N/A</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>LINK_ONLY</td></tr><tr><td>N/A</td><td>N/A</td><td>&nbsp;</td><td>X</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>ALL_GONE</td></tr><tr><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>AMBIGUOUS</td></tr><tr><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>X</td><td>&nbsp;</td><td>&nbsp;</td><td>X</td><td>UNQUALIFIED</td></tr></tbody><tbody class="footnotes"><tr><td colspan="8"><div id="ftn.d0e10017" class="footnote"><p><a href="#d0e10017" class="para"><sup class="para">[a] </sup></a>
          If no link exists for the source object, then OpenIDM executes a
          correlation query. If no previous object is available, OpenIDM cannot
          correlate.
         </p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sync-actions"></a>11.9.5.&nbsp;Synchronization Actions</h3></div></div></div><div class="variablelist"><p>Once OpenIDM has assigned a situation to an object, OpenIDM takes
    the actions configured in the mapping. If no action is configured, then
    OpenIDM takes the default action for the situation. OpenIDM supports the
    following actions.</p><dl class="variablelist"><dt><span class="term">"CREATE"</span></dt><dd><p>Create and link a target object.</p></dd><dt><span class="term">"UPDATE"</span></dt><dd><p>Link and update a target object.</p></dd><dt><span class="term">"DELETE"</span></dt><dd><p>Delete and unlink the target object.</p></dd><dt><span class="term">"LINK"</span></dt><dd><p>Link the correlated target object.</p></dd><dt><span class="term">"UNLINK"</span></dt><dd><p>Unlink the linked target object.</p></dd><dt><span class="term">"EXCEPTION"</span></dt><dd><p>Flag the link situation as an exception.</p><p>You should not use this action for LiveSync mappings.</p></dd><dt><span class="term">"IGNORE"</span></dt><dd><p>Do not change the link or target object state.</p></dd><dt><span class="term">"REPORT"</span></dt><dd><p>
       Do not perform any action but report on what would happen if the default
       action were performed.
      </p></dd><dt><span class="term">"NOREPORT"</span></dt><dd><p>
       Do not perform any action or generate any report.
      </p></dd><dt><span class="term">"ASYNC"</span></dt><dd><p>
       An asynchronous process has been started so do not perform any action or
       generate any report. 
      </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="script-actions"></a>11.9.6.&nbsp;Providing a Script as an Action</h3></div></div></div><p>
    In addition to the static synchronization actions described in the previous
    section, you can provide a script that is run in specific synchronization
    situations. The following extract of a sample <code class="filename">sync.json</code>
    file specifies that when a synchronization operation assesses an entry as
    <code class="literal">ABSENT</code>, the workflow named
    <code class="literal">managedUserApproval</code> is invoked. The parameters for the
    workflow are passed in as properties of the <code class="literal">action</code>
    parameter.
   </p><pre class="brush: javascript;">
{
    "situation" : "ABSENT",
    "action" : {
        "workflowName" : "managedUserApproval",
        "type" : "text/javascript",
        "file" : "workflow/triggerWorkflowFromSync.js"
    }
}
   </pre><p>
    The variables available to these scripts are described in
    <a href="../../integrators-guide/index/appendix-scripting.html" class="link"><em class="citetitle">Variables
     Available in Scripts</em></a> in the <em class="citetitle">Scripting
    Appendix</em>.
   </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="asynchronous-reconciliation"></a>11.10.&nbsp;Asynchronous Reconciliation</h2></div></div></div><p>Reconciliation can work in tandem with workflows to provide
   additional business logic to the reconciliation process. You can define
   scripts to determine the action that should be taken for a particular
   reconciliation situation. A reconciliation process can launch a workflow
   after it has assessed a situation, and then perform the reconciliation, or
   some other action.</p><p>For example, you might want a reconciliation process to assess new user
   accounts that need to be created on a target resource. However, new user
   account creation might require some kind of approval from a manager before
   the accounts are actually created. The initial reconciliation process can
   assess the accounts that need to be created, launch a workflow to request
   management approval for those accounts, and then relaunch the reconciliation
   process to create the accounts, once the management approval has been
   received.</p><p>In this scenario, the defined script returns <code class="literal">IGNORE</code>
   for new accounts and the reconciliation engine does not continue processing
   the given object. The script then initiates an asynchronous process which
   calls back and completes the reconciliation process at a later stage.</p><p>A sample configuration for this scenario is available in
   <code class="filename">openidm/samples/sample9</code>, and described in <a href="../../install-guide/index/chap-samples.html#more-sample9" class="link"><em class="citetitle">Sample 9 -
   Asynchronous Reconciliation Using Workflows</em></a> in the
   <em class="citetitle">Installation Guide</em>.</p><div class="orderedlist"><p>Configuring asynchronous reconciliation involves the following
     steps:</p><ol class="orderedlist" type="1"><li class="listitem"><p>Create the workflow definition file (<code class="literal">.xml or .bar</code> file)
       and place it in the <code class="filename">openidm/workflow</code> directory.
       For more information about creating workflows, see <a href="../../integrators-guide/index/chap-workflow.html" class="link">
       <em class="citetitle">Integrating Business Processes and Workflows</em></a>.
       </p></li><li class="listitem"><p>Modify the <code class="filename">conf/sync.json</code> file for the
       situation or situations that should call the workflow. Reference the
       workflow name in the configuration for that situation.</p><p>For example, the following <code class="filename">sync.json</code> extract
       calls the <code class="literal">managedUserApproval</code> workflow if the
       situation is assessed as <code class="literal">ABSENT</code>:</p><pre class="brush: javascript;">
{
    "situation" : "ABSENT",
    "action" : {
        "workflowName" : "managedUserApproval",
        "type" : "text/javascript",
        "file" : "workflow/triggerWorkflowFromSync.js"
    }
},    </pre></li><li class="listitem"><p>
       In the sample configuration, the workflow calls a second, explicit
       reconciliation process as a final step. This reconciliation process is
       called on the <code class="literal">sync</code> context path, with the
       <code class="literal">performAction</code> action
       (<code class="literal">openidm.action('sync', 'performAction', params)</code>).
      </p><p>
       You can also use this kind of explicit reconciliation to perform a
       specific action on a source or target record, regardless of the assessed
       situation.
      </p><p>
       You can call such an operation over the REST interface, specifying the
       source, and/or target IDs, the mapping, and the action to be taken. The
       action can be any one of the supported reconciliation actions, that is,
       <code class="literal">CREATE, UPDATE, DELETE, LINK, UNLINK, EXCEPTION, REPORT,
       NOREPORT, ASYNC, IGNORE</code>. In addition, if you specify a
       <code class="literal">reconId</code>, the action that is taken is logged in the
       <code class="literal">audit/recon</code> log, along with the the other audit data
       for that reconciliation run.
      </p><p>
       The following sample command calls the DELETE action on user
       <code class="literal">bjensen</code>, whose <code class="literal">_id</code> in the LDAP
       directory is <code class="literal">uid=bjensen,ou=People,dc=example,dc=com</code>.
       The user is deleted in the target resource, in this case, the
       OpenIDM repository.
      </p><p>
       Note that the <code class="literal">_id</code> must be URL-encoded in the REST
       call.
      </p><div class="screen"><pre><strong>$ curl \
 --cacert self-signed.crt \
 --header "X-OpenIDM-Username: openidm-admin" \
 --header "X-OpenIDM-Password: openidm-admin" \
 --header "Content-Type: application/json" \
 --request POST \
 "https://localhost:8443/openidm/sync?_action=performAction&amp;sourceId=uid%3Dbjensen%2Cou%3DPeople%2Cdc%3Dexample%2Cdc%3Dcom&amp;mapping=
 systemLdapAccounts_ManagedUser&amp;action=DELETE"</strong>
<em>{}</em></pre></div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="case-sensitivity"></a>11.11.&nbsp;Configuring Case Sensitivity for Data Stores</h2></div></div></div><p>By default, OpenIDM is case-sensitive, which means that case is taken
   into account when comparing IDs during reconciliation. For data stores that
   are case-insensitive, such as OpenDJ, IDs and links that are created by a
   reconciliation process may be stored with a different case to the way in
   which they are stored in the OpenIDM repository. Such a situation can cause
   problems during a reconciliation operation, as the links for these IDs may
   not match.</p><p>For such data stores, you can configure OpenIDM to ignore case during
   reconciliation operations. With case sensitivity turned off in OpenIDM, for
   those specific mappings, comparisons are done without regard to case.</p><p>To specify that data stores are not case-sensitive, set the
   <code class="literal">"sourceIdsCaseSensitive"</code> or <code class="literal">"targetIdsCaseSensitive"</code>
   property to <code class="literal">false</code> in the mapping for those links. For
   example, if the LDAP data store is case-insensitive, set the mapping from
   the LDAP store to the managed user repository as follows:</p><pre class="brush: javascript;">
"mappings" : [
{
"name" : "systemLdapAccounts_managedUser",
"source" : "system/ldap/account",
"sourceIdsCaseSensitive" : false,
"target" : "managed/user",
"properties" : [
...
   </pre><p>If a mapping inherits links by using the <code class="literal">"links"</code>
   property, it is not necessary to set case sensitivity, because the mapping
   uses the setting of the referred links.</p><p>
    Note that configuring OpenIDM to be case-insensitive when comparing links
    does not make the OpenICF provisioner case-insensitive when it requests
    data. For example, if a user entry is stored with the ID
    <code class="literal">testuser</code> and you make a request for
    <code class="literal">https://localhost:8443/openidm/managed/TESTuser</code>, most
    provisioners will filter out the match because of the difference in case,
    and will indicate that the record is not found. To prevent the provisioner
    from performing this secondary filtering, set the
    <code class="literal">enableFilteredResultsHandler</code> property to
    <code class="literal">false</code> in the provisioner configuration. For example:
   </p><div class="screen"><pre>"resultsHandlerConfig" :
{
    "enableFilteredResultsHandler":false,
}, </pre></div><div class="caution"><h3 class="title">Caution</h3><p>Do not disable the filtered results handler for the CSV file
     connector. The CSV file connector does not perform filtering so if you
     disable the filtered results handler for this connector, the full CSV
     file will be returned for every request.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reconciliation-optimization"></a>11.12.&nbsp;Reconciliation Optimization</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#correlate-target-set">11.12.1. Correlating Empty Target Sets</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#prefetching-links">11.12.2. Prefetching Links</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#parallel-recon-tasks">11.12.3. Parallel Reconciliation Threads</a></span></dt></dl></div><p>By default, reconciliation is configured to function in an optimized
  way. Some of these optimizations might, however, be unsuitable for your
  environment. The following sections describe the optimizations and how they
  can be configured.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="correlate-target-set"></a>11.12.1.&nbsp;Correlating Empty Target Sets</h3></div></div></div><p>To optimize a reconciliation operation, the reconciliation process does
  not attempt to correlate source objects to target objects if the set of
  target objects is empty when the correlation is started. This considerably
  speeds up the process the first time the reconciliation is run. You can change
  this behavior for a specific mapping by adding the
  <code class="literal">correlateEmptyTargetSet</code> property to the mapping definition
  and setting it to <code class="literal">true</code>. For example:</p><pre class="brush: javascript;">
{
    "mappings": [
        {
            "name"                     : "systemMyLDAPAccounts_managedUser",
            "source"                   : "system/MyLDAP/account",
            "target"                   : "managed/user",
            "correlateEmptyTargetSet"  : true
        },
    ]
}</pre><p>Be aware that this setting will have a performance impact on the
   reconciliation process.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="prefetching-links"></a>11.12.2.&nbsp;Prefetching Links</h3></div></div></div><p>All links are queried at the start of a correlation and the results of
   that query are used. You can disable the prefetching of links, so that the
   correlation process looks up each link in the database as it processes each
   source or target object. You can disable the prefetching of links by adding
   the <code class="literal">prefetchLinks</code> property to the mapping, and setting it
   to <code class="literal">false</code>, for example:</p><pre class="brush: javascript;">
{
    "mappings": [
        {
            "name": "systemMyLDAPAccounts_managedUser",
            "source": "system/MyLDAP/account",
            "target": "managed/user"
            "prefetchLinks" : false
        }
    ]
}</pre><p>Be aware that this setting will have a performance impact on the
   reconciliation process.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="parallel-recon-tasks"></a>11.12.3.&nbsp;Parallel Reconciliation Threads</h3></div></div></div><p>By default, reconciliation is executed in a multi-threaded manner,
    that is, numerous threads are dedicated to the same reconciliation run.
    Multithreading generally improves reconciliation run performance. The
    default number of threads for a single reconciliation run is ten (plus the
    main reconciliation thread). Under normal circumstances, you should not
    need to change this number, however the default might not be appropriate
    in the following situations:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The hardware has many cores and supports more concurrent threads.
        As a rule of thumb for performance tuning, start with setting the
        thread number to two times the number of cores.</p></li><li class="listitem"><p>The source or target is an external system with high latency or
       slow response times. Threads may then spend considerable time waiting
       for a response from the external system. Increasing the available
       threads enables the system to prepare or continue with additional
       objects.</p></li></ul></div><p>To change the number of threads, set the <code class="literal">taskThreads</code>
    property in the <code class="filename">conf/sync.json</code> file, for example:</p><pre class="brush: javascript;">
    "mappings" : [
        {
            "name" : "systemXmlfileAccounts_managedUser",
            "source" : "system/xmlfile/account",
            "target" : "managed/user",
            "taskThreads" : 20
            ...
         }
    ]
}</pre><p>A value of <code class="literal">0</code> specifies that reconciliation is run
    on the main reconciliation thread, that is, in a serial manner.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="correlation"></a>11.13.&nbsp;Correlation Queries</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#correlation-query-managed-object">11.13.1. Managed Objects as Correlation Query Targets</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#correlation-query-system-object">11.13.2. System Objects as Correlation Query Targets</a></span></dt></dl></div><a class="indexterm" name="d0e10421"></a><a class="indexterm" name="d0e10426"></a><p>Every time OpenIDM creates an object through synchronization, it
  creates a link between the source and target objects. OpenIDM then uses the
  link to determine the object's situation during later synchronization
  operations.</p><p>Initial, bulk synchronization operations can involve correlating
  many objects that exist both on source and target systems. In this case,
  OpenIDM uses correlation queries to find target objects that already exist,
  and that correspond to source objects. For the target objects that match
  a correlation query, OpenIDM needs only to create a link, rather than a
  new target object.</p><p>Correlation queries run against target resources. The query syntax
  therefore depends on the target system, and is either specific to the data
  store underlying the OpenIDM repository, or to OpenICF query capabilities.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="correlation-query-managed-object"></a>11.13.1.&nbsp;Managed Objects as Correlation Query Targets</h3></div></div></div><p>Queries on managed objects in the repository must be defined in the
   configuration file for the repository, which is either
   <code class="filename">openidm/conf/repo.orientdb.json</code>, or
   <code class="filename">openidm/conf/repo.jdbc.json</code>.</p><p>The following example shows a correlation query defined in
   <code class="filename">openidm/conf/repo.orientdb.json</code>.</p><pre class="brush: javascript;">
"for-userName" : "SELECT * FROM ${unquoted:_resource} WHERE userName = ${uid}"
</pre><p>By default, a <code class="literal">${value}</code> token replacement is
   assumed to be a quoted string. If the value is not a quoted string, use the
   <code class="literal">unquoted:</code> prefix, as shown above.</p><p>The following correlation query example shows the JavaScript to call
   the query defined for OrientDB. The <code class="literal">_queryId</code> property
   value matches the name of the query specified in
   <code class="filename">openidm/conf/repo.orientdb.json</code>,
   <code class="literal">for-userName</code>. The <code class="literal">source.name</code> value
   replaces <code class="literal">${uid}</code> in the query. OpenIDM replaces
   <code class="literal">${unquoted:_resource}</code> in the query with the name of the
   table that holds managed objects.</p><pre class="brush: javascript;">
{
  "correlationQuery": {
    "type": "text/javascript",
    "source":
      "var query = {'_queryId' : 'for-userName', 'uid' : source.name}; query;"
  }
}</pre><p>The query can return zero or more objects, so the situation OpenIDM
   assigns to the source object depends on the number of target objects
   returned.</p><p>With a JDBC-based repository, the query defined in
   <code class="filename">openidm/conf/repo.jdbc.json</code> is more complex due
   to how the tables are indexed. The correlation query you define in
   <code class="filename">openidm/conf/sync.json</code> is the same, however.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="correlation-query-system-object"></a>11.13.2.&nbsp;System Objects as Correlation Query Targets</h3></div></div></div><p>
    Correlation queries on system objects access the connector. The connector
    then executes the query on the external resource.
   </p><p>
    Your correlation query JavaScript must return a map that holds a generic
    query with the following elements:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      A condition, such as "Equals"
     </p></li><li class="listitem"><p>
      The naming attribute to compare on the system object. In the example that
      follows, the naming attribute is <code class="literal">uid</code>.
     </p></li><li class="listitem"><p>
      The value from the source object to use in the search filter. You set this
      as the value of the <code class="literal">value</code> property, which takes an
      array. In the example that follows, the value to use in the search filter
      is <code class="literal">source.userName</code>.
     </p></li></ul></div><pre class="brush: javascript;">
var map = {"_queryFilter": 'uid eq "' + source.userName + '"'};
map;
   </pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-dataflow"></a>11.14.&nbsp;Advanced Data Flow Configuration</h2></div></div></div><a class="indexterm" name="d0e10524"></a><p><a class="xref" href="chap-synchronization.html#basic-flow" title="11.3.&nbsp;Basic Data Flow Configuration">Section&nbsp;11.3, &#8220;Basic Data Flow Configuration&#8221;</a> shows how to trigger scripts when objects
  are created and updated. Other situations require you to trigger scripts
  in response to other synchronization actions. For example, you might not
  want OpenIDM to delete a managed user directly when an external account is
  deleted, but instead unlink the objects and deactivate the user in another
  resource. (Alternatively, you might delete the object in OpenIDM but
  nevertheless execute a script.) The following example shows a more advanced
  mapping configuration.</p><pre class="brush: javascript;">{
    "mappings": [
        {
            "name": "systemLdapAccount_managedUser",
            "source": "system/ldap/account",
            "target": "managed/user",
            "validSource": {
                "type": "text/javascript",
                "file": "script/isValid.js"
            },
            "correlationQuery" : {
                "type" : "text/javascript",
                "source" : "var map = {'_queryFilter': 'uid eq \"' +
                     source.userName + '\"'}; map;"
            },
            "properties": [
                {
                    "source": "uid",
                    "transform": {
                        "type": "text/javascript",
                        "source": "source.toLowerCase()"
                    },
                    "target": "userName"
                },
                {
                    "source": "",
                    "transform": {
                        "type": "text/javascript",
                        "source": "if (source.myGivenName)
                            {source.myGivenName;} else {source.givenName;}"
                    },
                    "target": "givenName"
                },
                {
                    "source": "",
                    "transform": {
                        "type": "text/javascript",
                        "source": "if (source.mySn)
                            {source.mySn;} else {source.sn;}"
                    },
                    "target": "familyName"
                },
                {
                    "source": "cn",
                    "target": "fullname"
                },
                {
                    "comment": "Multi-valued in LDAP, single-valued in AD.
                        Retrieve first non-empty value.",
                    "source": "title",
                    "transform": {
                        "type": "text/javascript",
                        "file": "script/getFirstNonEmpty.js"
                    },
                    "target": "title"
                },
                {
                    "condition": {
                        "type": "text/javascript",
                        "source": "var clearObj = openidm.decrypt(object);
                            ((clearObj.password != null) &amp;&amp;
                            (clearObj.ldapPassword != clearObj.password))"
                    },
                    "transform": {
                        "type": "text/javascript",
                        "source": "source.password"
                    },
                    "target": "__PASSWORD__"
                }
            ],
            "onCreate": {
                "type": "text/javascript",
                "source": "target.ldapPassword = null;
                    target.adPassword = null;
                    target.password = null;
                    target.ldapStatus = 'New Account'"
            },
            "onUpdate": {
                "type": "text/javascript",
                "source": "target.ldapStatus = 'OLD'"
            },
            "onUnlink": {
                "type": "text/javascript",
                "file": "script/triggerAdDisable.js"
            },
            "policies": [
                {
                    "situation": "CONFIRMED",
                    "action": "UPDATE"
                },
                {
                    "situation": "FOUND",
                    "action": "UPDATE"
                },
                {
                    "situation": "ABSENT",
                    "action": "CREATE"
                },
                {
                    "situation": "AMBIGUOUS",
                    "action": "EXCEPTION"
                },
                {
                    "situation": "MISSING",
                    "action": "EXCEPTION"
                },
                {
                    "situation": "UNQUALIFIED",
                    "action": "UNLINK"
                },
                {
                    "situation": "UNASSIGNED",
                    "action": "EXCEPTION"
                }
            ]
        }
    ]
}</pre><div class="variablelist"><p>The following list shows all the properties that you can use as hooks
   in mapping configurations to call scripts.</p><dl class="variablelist"><dt><span class="term">Triggered by Situation</span></dt><dd><p>onCreate, onRead, onUpdate, onDelete, onValidate, onRetrieve,
      onStore, onLink, onUnlink, postCreate, postUpdate, postDelete</p></dd><dt><span class="term">Object Filter</span></dt><dd><p>vaildSource, validTarget</p></dd><dt><span class="term">Correlating Objects</span></dt><dd><p>correlationQuery</p></dd><dt><span class="term">Triggered on Reconciliation</span></dt><dd><p>result</p></dd><dt><span class="term">Scripts Inside Properties</span></dt><dd><p>condition, transform</p></dd></dl></div><p>Your scripts can get data from any connected system at any time by
  using the <code class="literal">openidm.read(id)</code> function, where
  <code class="literal">id</code> is the identifier of the object to read.</p><p>The following example reads a managed user object from the
  repository.</p><pre class="brush: javascript;">
repoUser = openidm.read("managed/user/ddoe");</pre><p>The following example reads an account from an external LDAP
  resource.</p><pre class="brush: javascript;">
externalAccount = openidm.read("system/ldap/account/uid=ddoe,ou=People,dc=example,dc=com");</pre><p>Note that the query targets a DN rather than a UID, as it did in the
  previous example. The attribute that is used for the <code class="literal">_id</code>
  is defined in the connector configuration file and, in this example, is set
  to <code class="literal">"uidAttribute" : "dn"</code>. Although it is possible to use
  a DN (or any unique attribute) for the <code class="literal">_id</code>, as a best
  practice, you should use an attribute that is both unique and immutable.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scheduling-synchronization"></a>11.15.&nbsp;Scheduling Synchronization</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="chap-synchronization.html#configuring-sync-schedule">11.15.1. Configuring Scheduled Synchronization</a></span></dt><dt><span class="section"><a href="chap-synchronization.html#alternative-mapping">11.15.2. Alternative Mappings</a></span></dt></dl></div><a class="indexterm" name="d0e10598"></a><a class="indexterm" name="d0e10601"></a><a class="indexterm" name="d0e10606"></a><a class="indexterm" name="d0e10611"></a><p>You can schedule synchronization operations, such as LiveSync and
  reconciliation, using <span class="command"><strong>cron</strong></span>-like syntax.</p><p>This section describes scheduling for reconciliation and LiveSync,
  however, you can also use OpenIDM's scheduler service to schedule any other
  event by supplying a link to a script file, in which that event is defined.
  For information about scheduling other events, and for a deeper understanding
  of the OpenIDM scheduler service, see
  <a href="../../integrators-guide/index/chap-scheduler-conf.html" class="link"><em class="citetitle">Scheduling Tasks
  and Events</em></a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="configuring-sync-schedule"></a>11.15.1.&nbsp;Configuring Scheduled Synchronization</h3></div></div></div><p>
    Each scheduled reconciliation and LiveSync task requires a schedule
    configuration file in <code class="filename">openidm/conf</code>. By convention,
    files are named
    <code class="filename">openidm/conf/schedule-<em class="replaceable"><code>schedule-name</code></em>
    .json</code>, where <em class="replaceable"><code>schedule-name</code></em> is a
    logical name for the scheduled synchronization operation, such as
    <code class="literal">reconcile_systemXmlAccounts_managedUser</code>.
   </p><p>
    Schedule configuration files have the following format:
   </p><pre class="brush: javascript;">
{
 "enabled"       : true,
 "persisted"     : false,
 "type"          : "cron",
 "startTime"     : "(optional) time",
 "endTime"       : "(optional) time",
 "schedule"      : "cron expression",
 "misfirePolicy" : "optional, string",
 "timeZone"      : "(optional) time zone",
 "invokeService" : "service identifier",
 "invokeContext" : "service specific context info"
}
   </pre><p>
    For an explanation of each of these properties, see
    <a href="../../integrators-guide/index/chap-scheduler-conf.html" class="link"><em class="citetitle">Scheduling Tasks
    and Events</em></a>.
   </p><p>
    To schedule a reconciliation or LiveSync task, set the
    <code class="literal">invokeService</code> property to either
    <code class="literal">"sync"</code> (for reconciliation) or
    <code class="literal">"provisioner"</code> for LiveSync.
   </p><p>
    The value of the <code class="literal">invokeContext</code> property depends on the
    type of scheduled event. For reconciliation, the properties are set as
    follows:
   </p><pre class="brush: javascript;">
{
    "invokeService": "sync",
    "invokeContext": {
        "action": "reconcile",
        "mapping": "systemLdapAccount_managedUser"
    }
}
   </pre><p>
    The <code class="literal">"mapping"</code> is either referenced by its name in the
    <code class="filename">openidm/conf/sync.json</code> file, or defined inline by using
    the <code class="literal">"mapping"</code> property, as shown in the example in
    <a href="../../integrators-guide/index/chap-synchronization.html#alternative-mapping" class="link"><em class="citetitle">Alternative
    Mappings</em></a>.
   </p><p>
    For LiveSync, the properties are set as follows:
   </p><pre class="brush: javascript;">
{
    "invokeService": "provisioner",
    "invokeContext": {
        "action": "liveSync",
        "source": "system/OpenDJ/__ACCOUNT__"
    }
}
   </pre><p>
    The <code class="literal">"source"</code> property follows OpenIDM's convention for a
    pointer to an external resource object and takes the form
    <code class="literal">system/<em class="replaceable"><code>resource-name/object-type</code></em></code>.
   </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alternative-mapping"></a>11.15.2.&nbsp;Alternative Mappings</h3></div></div></div><a class="indexterm" name="d0e10728"></a><p>
    Mappings for synchronization are usually stored in
    <code class="filename">openidm/conf/sync.json</code> for reconciliation, LiveSync,
    and for pushing changes made to managed objects to external resources. You
    can, however, provide alternative mappings for scheduled reconciliation by
    adding the mapping to the schedule configuration instead of referencing a
    mapping in <code class="filename">sync.json</code>.
   </p><pre class="brush: javascript;">
{
    "enabled": true,
    "type": "cron",
    "schedule": "0 08 16 * * ?",
    "invokeService": "sync",
    "invokeContext": {
        "action": "reconcile",
        "mapping": {
            "name": "CSV_XML",
            "source": "system/Ldap/account",
            "target": "managed/user",
            "properties": [
                {
                    "source": "firstname",
                    "target": "firstname"
                },
                ...
            ],
            "policies": [...]
        }
    }
}
   </pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chap-resource-conf.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="chap-scheduler-conf.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;Connecting to External Resources&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;12.&nbsp;Scheduling Tasks and Events</td></tr></table></div><p>&nbsp;</p><div id="footer"><p>Something wrong on this page? <a href="https://bugster.forgerock.org/jira/secure/CreateIssueDetails!init.jspa?pid=10020&components=10164&issuetype=1">Log a documentation bug.</a></p></div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23412190-9']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body></html>